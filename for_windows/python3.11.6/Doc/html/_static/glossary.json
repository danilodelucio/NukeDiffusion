{">>>": {"title": ">>>", "body": "<main>\n<dd><p>The default Python prompt of the interactive shell.  Often seen for code\nexamples which can be executed interactively in the interpreter.</p>\n</dd>\n</main>\n"}, "...": {"title": "...", "body": "<main>\n<dd><p>Can refer to:</p>\n<ul class=\"simple\">\n<li><p>The default Python prompt of the interactive shell when entering the\ncode for an indented code block, when within a pair of matching left and\nright delimiters (parentheses, square brackets, curly braces or triple\nquotes), or after specifying a decorator.</p></li>\n<li><p>The <a class=\"reference internal\" href=\"library/constants.html#Ellipsis\" title=\"Ellipsis\"><code class=\"xref py py-const docutils literal notranslate\"><span class=\"pre\">Ellipsis</span></code></a> built-in constant.</p></li>\n</ul>\n</dd>\n</main>\n"}, "2to3": {"title": "2to3", "body": "<main>\n<dd><p>A tool that tries to convert Python 2.x code to Python 3.x code by\nhandling most of the incompatibilities which can be detected by parsing the\nsource and traversing the parse tree.</p>\n<p>2to3 is available in the standard library as <a class=\"reference internal\" href=\"library/2to3.html#module-lib2to3\" title=\"lib2to3: The 2to3 library\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">lib2to3</span></code></a>; a standalone\nentry point is provided as <code class=\"file docutils literal notranslate\"><span class=\"pre\">Tools/scripts/2to3</span></code>.  See\n<a class=\"reference internal\" href=\"library/2to3.html#to3-reference\"><span class=\"std std-ref\">2to3 \u2014 Automated Python 2 to 3 code translation</span></a>.</p>\n</dd>\n</main>\n"}, "abstract base class": {"title": "abstract base class", "body": "<main>\n<dd><p>Abstract base classes complement <a class=\"reference internal\" href=\"#term-duck-typing\"><span class=\"xref std std-term\">duck-typing</span></a> by\nproviding a way to define interfaces when other techniques like\n<a class=\"reference internal\" href=\"library/functions.html#hasattr\" title=\"hasattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">hasattr()</span></code></a> would be clumsy or subtly wrong (for example with\n<a class=\"reference internal\" href=\"reference/datamodel.html#special-lookup\"><span class=\"std std-ref\">magic methods</span></a>).  ABCs introduce virtual\nsubclasses, which are classes that don\u2019t inherit from a class but are\nstill recognized by <a class=\"reference internal\" href=\"library/functions.html#isinstance\" title=\"isinstance\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">isinstance()</span></code></a> and <a class=\"reference internal\" href=\"library/functions.html#issubclass\" title=\"issubclass\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">issubclass()</span></code></a>; see the\n<a class=\"reference internal\" href=\"library/abc.html#module-abc\" title=\"abc: Abstract base classes according to :pep:`3119`.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">abc</span></code></a> module documentation.  Python comes with many built-in ABCs for\ndata structures (in the <a class=\"reference internal\" href=\"library/collections.abc.html#module-collections.abc\" title=\"collections.abc: Abstract base classes for containers\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">collections.abc</span></code></a> module), numbers (in the\n<a class=\"reference internal\" href=\"library/numbers.html#module-numbers\" title=\"numbers: Numeric abstract base classes (Complex, Real, Integral, etc.).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">numbers</span></code></a> module), streams (in the <a class=\"reference internal\" href=\"library/io.html#module-io\" title=\"io: Core tools for working with streams.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">io</span></code></a> module), import finders\nand loaders (in the <a class=\"reference internal\" href=\"library/importlib.html#module-importlib.abc\" title=\"importlib.abc: Abstract base classes related to import\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">importlib.abc</span></code></a> module).  You can create your own\nABCs with the <a class=\"reference internal\" href=\"library/abc.html#module-abc\" title=\"abc: Abstract base classes according to :pep:`3119`.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">abc</span></code></a> module.</p>\n</dd>\n</main>\n"}, "annotation": {"title": "annotation", "body": "<main>\n<dd><p>A label associated with a variable, a class\nattribute or a function parameter or return value,\nused by convention as a <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hint</span></a>.</p>\n<p>Annotations of local variables cannot be accessed at runtime, but\nannotations of global variables, class attributes, and functions\nare stored in the <code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__annotations__</span></code>\nspecial attribute of modules, classes, and functions,\nrespectively.</p>\n<p>See <a class=\"reference internal\" href=\"#term-variable-annotation\"><span class=\"xref std std-term\">variable annotation</span></a>, <a class=\"reference internal\" href=\"#term-function-annotation\"><span class=\"xref std std-term\">function annotation</span></a>, <span class=\"target\" id=\"index-0\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>\nand <span class=\"target\" id=\"index-1\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0526/\"><strong>PEP 526</strong></a>, which describe this functionality.\nAlso see <a class=\"reference internal\" href=\"howto/annotations.html#annotations-howto\"><span class=\"std std-ref\">Annotations Best Practices</span></a>\nfor best practices on working with annotations.</p>\n</dd>\n</main>\n"}, "argument": {"title": "argument", "body": "<main>\n<dd><p>A value passed to a <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a> (or <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">method</span></a>) when calling the\nfunction.  There are two kinds of argument:</p>\n<ul>\n<li><p><em class=\"dfn\">keyword argument</em>: an argument preceded by an identifier (e.g.\n<code class=\"docutils literal notranslate\"><span class=\"pre\">name=</span></code>) in a function call or passed as a value in a dictionary\npreceded by <code class=\"docutils literal notranslate\"><span class=\"pre\">**</span></code>.  For example, <code class=\"docutils literal notranslate\"><span class=\"pre\">3</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> are both keyword\narguments in the following calls to <a class=\"reference internal\" href=\"library/functions.html#complex\" title=\"complex\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">complex()</span></code></a>:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"n\">real</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">imag</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"p\">{</span><span class=\"s1\">&#39;real&#39;</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"s1\">&#39;imag&#39;</span><span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">})</span>\n</pre></div>\n</div>\n</li>\n<li><p><em class=\"dfn\">positional argument</em>: an argument that is not a keyword argument.\nPositional arguments can appear at the beginning of an argument list\nand/or be passed as elements of an <a class=\"reference internal\" href=\"#term-iterable\"><span class=\"xref std std-term\">iterable</span></a> preceded by <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code>.\nFor example, <code class=\"docutils literal notranslate\"><span class=\"pre\">3</span></code> and <code class=\"docutils literal notranslate\"><span class=\"pre\">5</span></code> are both positional arguments in the\nfollowing calls:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"nb\">complex</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n</pre></div>\n</div>\n</li>\n</ul>\n<p>Arguments are assigned to the named local variables in a function body.\nSee the <a class=\"reference internal\" href=\"reference/expressions.html#calls\"><span class=\"std std-ref\">Calls</span></a> section for the rules governing this assignment.\nSyntactically, any expression can be used to represent an argument; the\nevaluated value is assigned to the local variable.</p>\n<p>See also the <a class=\"reference internal\" href=\"#term-parameter\"><span class=\"xref std std-term\">parameter</span></a> glossary entry, the FAQ question on\n<a class=\"reference internal\" href=\"faq/programming.html#faq-argument-vs-parameter\"><span class=\"std std-ref\">the difference between arguments and parameters</span></a>, and <span class=\"target\" id=\"index-2\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0362/\"><strong>PEP 362</strong></a>.</p>\n</dd>\n</main>\n"}, "asynchronous context manager": {"title": "asynchronous context manager", "body": "<main>\n<dd><p>An object which controls the environment seen in an\n<a class=\"reference internal\" href=\"reference/compound_stmts.html#async-with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">with</span></code></a> statement by defining <a class=\"reference internal\" href=\"reference/datamodel.html#object.__aenter__\" title=\"object.__aenter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aenter__()</span></code></a> and\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__aexit__\" title=\"object.__aexit__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aexit__()</span></code></a> methods.  Introduced by <span class=\"target\" id=\"index-3\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "asynchronous generator": {"title": "asynchronous generator", "body": "<main>\n<dd><p>A function which returns an <a class=\"reference internal\" href=\"#term-asynchronous-generator-iterator\"><span class=\"xref std std-term\">asynchronous generator iterator</span></a>.  It\nlooks like a coroutine function defined with <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-def\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code></a> except\nthat it contains <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> expressions for producing a series of\nvalues usable in an <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a> loop.</p>\n<p>Usually refers to an asynchronous generator function, but may refer to an\n<em>asynchronous generator iterator</em> in some contexts.  In cases where the\nintended meaning isn\u2019t clear, using the full terms avoids ambiguity.</p>\n<p>An asynchronous generator function may contain <a class=\"reference internal\" href=\"reference/expressions.html#await\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">await</span></code></a>\nexpressions as well as <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a>, and <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">with</span></code></a>\nstatements.</p>\n</dd>\n</main>\n"}, "asynchronous generator iterator": {"title": "asynchronous generator iterator", "body": "<main>\n<dd><p>An object created by a <a class=\"reference internal\" href=\"#term-asynchronous-generator\"><span class=\"xref std std-term\">asynchronous generator</span></a> function.</p>\n<p>This is an <a class=\"reference internal\" href=\"#term-asynchronous-iterator\"><span class=\"xref std std-term\">asynchronous iterator</span></a> which when called using the\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a> method returns an awaitable object which will execute\nthe body of the asynchronous generator function until the next\n<a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> expression.</p>\n<p>Each <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> temporarily suspends processing, remembering the\nlocation execution state (including local variables and pending\ntry-statements).  When the <em>asynchronous generator iterator</em> effectively\nresumes with another awaitable returned by <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a>, it\npicks up where it left off.  See <span class=\"target\" id=\"index-4\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a> and <span class=\"target\" id=\"index-5\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0525/\"><strong>PEP 525</strong></a>.</p>\n</dd>\n</main>\n"}, "asynchronous iterable": {"title": "asynchronous iterable", "body": "<main>\n<dd><p>An object, that can be used in an <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a> statement.\nMust return an <a class=\"reference internal\" href=\"#term-asynchronous-iterator\"><span class=\"xref std std-term\">asynchronous iterator</span></a> from its\n<a class=\"reference internal\" href=\"reference/datamodel.html#object.__aiter__\" title=\"object.__aiter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aiter__()</span></code></a> method.  Introduced by <span class=\"target\" id=\"index-6\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "asynchronous iterator": {"title": "asynchronous iterator", "body": "<main>\n<dd><p>An object that implements the <a class=\"reference internal\" href=\"reference/datamodel.html#object.__aiter__\" title=\"object.__aiter__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__aiter__()</span></code></a> and <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a>\nmethods.  <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a> must return an <a class=\"reference internal\" href=\"#term-awaitable\"><span class=\"xref std std-term\">awaitable</span></a> object.\n<a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a> resolves the awaitables returned by an asynchronous\niterator\u2019s <a class=\"reference internal\" href=\"reference/datamodel.html#object.__anext__\" title=\"object.__anext__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__anext__()</span></code></a> method until it raises a\n<a class=\"reference internal\" href=\"library/exceptions.html#StopAsyncIteration\" title=\"StopAsyncIteration\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">StopAsyncIteration</span></code></a> exception.  Introduced by <span class=\"target\" id=\"index-7\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "attribute": {"title": "attribute", "body": "<main>\n<dd><p>A value associated with an object which is usually referenced by name\nusing dotted expressions.\nFor example, if an object <em>o</em> has an attribute\n<em>a</em> it would be referenced as <em>o.a</em>.</p>\n<p>It is possible to give an object an attribute whose name is not an\nidentifier as defined by <a class=\"reference internal\" href=\"reference/lexical_analysis.html#identifiers\"><span class=\"std std-ref\">Identifiers and keywords</span></a>, for example using\n<a class=\"reference internal\" href=\"library/functions.html#setattr\" title=\"setattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">setattr()</span></code></a>, if the object allows it.\nSuch an attribute will not be accessible using a dotted expression,\nand would instead need to be retrieved with <a class=\"reference internal\" href=\"library/functions.html#getattr\" title=\"getattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">getattr()</span></code></a>.</p>\n</dd>\n</main>\n"}, "awaitable": {"title": "awaitable", "body": "<main>\n<dd><p>An object that can be used in an <a class=\"reference internal\" href=\"reference/expressions.html#await\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">await</span></code></a> expression.  Can be\na <a class=\"reference internal\" href=\"#term-coroutine\"><span class=\"xref std std-term\">coroutine</span></a> or an object with an <a class=\"reference internal\" href=\"reference/datamodel.html#object.__await__\" title=\"object.__await__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__await__()</span></code></a> method.\nSee also <span class=\"target\" id=\"index-8\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "bdfl": {"title": "BDFL", "body": "<main>\n<dd><p>Benevolent Dictator For Life, a.k.a. <a class=\"reference external\" href=\"https://gvanrossum.github.io/\">Guido van Rossum</a>, Python\u2019s creator.</p>\n</dd>\n</main>\n"}, "binary file": {"title": "binary file", "body": "<main>\n<dd><p>A <a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file object</span></a> able to read and write\n<a class=\"reference internal\" href=\"#term-bytes-like-object\"><span class=\"xref std std-term\">bytes-like objects</span></a>.\nExamples of binary files are files opened in binary mode (<code class=\"docutils literal notranslate\"><span class=\"pre\">'rb'</span></code>,\n<code class=\"docutils literal notranslate\"><span class=\"pre\">'wb'</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">'rb+'</span></code>), <code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdin.buffer</span></code>,\n<code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdout.buffer</span></code>, and instances of <a class=\"reference internal\" href=\"library/io.html#io.BytesIO\" title=\"io.BytesIO\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">io.BytesIO</span></code></a> and\n<a class=\"reference internal\" href=\"library/gzip.html#gzip.GzipFile\" title=\"gzip.GzipFile\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">gzip.GzipFile</span></code></a>.</p>\n<p>See also <a class=\"reference internal\" href=\"#term-text-file\"><span class=\"xref std std-term\">text file</span></a> for a file object able to read and write\n<a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> objects.</p>\n</dd>\n</main>\n"}, "borrowed reference": {"title": "borrowed reference", "body": "<main>\n<dd><p>In Python\u2019s C API, a borrowed reference is a reference to an object,\nwhere the code using the object does not own the reference.\nIt becomes a dangling\npointer if the object is destroyed. For example, a garbage collection can\nremove the last <a class=\"reference internal\" href=\"#term-strong-reference\"><span class=\"xref std std-term\">strong reference</span></a> to the object and so destroy it.</p>\n<p>Calling <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_INCREF\" title=\"Py_INCREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_INCREF()</span></code></a> on the <a class=\"reference internal\" href=\"#term-borrowed-reference\"><span class=\"xref std std-term\">borrowed reference</span></a> is\nrecommended to convert it to a <a class=\"reference internal\" href=\"#term-strong-reference\"><span class=\"xref std std-term\">strong reference</span></a> in-place, except\nwhen the object cannot be destroyed before the last usage of the borrowed\nreference. The <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_NewRef\" title=\"Py_NewRef\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_NewRef()</span></code></a> function can be used to create a new\n<a class=\"reference internal\" href=\"#term-strong-reference\"><span class=\"xref std std-term\">strong reference</span></a>.</p>\n</dd>\n</main>\n"}, "bytes-like object": {"title": "bytes-like object", "body": "<main>\n<dd><p>An object that supports the <a class=\"reference internal\" href=\"c-api/buffer.html#bufferobjects\"><span class=\"std std-ref\">Buffer Protocol</span></a> and can\nexport a C-<a class=\"reference internal\" href=\"#term-contiguous\"><span class=\"xref std std-term\">contiguous</span></a> buffer. This includes all <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>,\n<a class=\"reference internal\" href=\"library/stdtypes.html#bytearray\" title=\"bytearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytearray</span></code></a>, and <a class=\"reference internal\" href=\"library/array.html#array.array\" title=\"array.array\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">array.array</span></code></a> objects, as well as many\ncommon <a class=\"reference internal\" href=\"library/stdtypes.html#memoryview\" title=\"memoryview\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">memoryview</span></code></a> objects.  Bytes-like objects can\nbe used for various operations that work with binary data; these include\ncompression, saving to a binary file, and sending over a socket.</p>\n<p>Some operations need the binary data to be mutable.  The documentation\noften refers to these as \u201cread-write bytes-like objects\u201d.  Example\nmutable buffer objects include <a class=\"reference internal\" href=\"library/stdtypes.html#bytearray\" title=\"bytearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytearray</span></code></a> and a\n<a class=\"reference internal\" href=\"library/stdtypes.html#memoryview\" title=\"memoryview\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">memoryview</span></code></a> of a <a class=\"reference internal\" href=\"library/stdtypes.html#bytearray\" title=\"bytearray\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytearray</span></code></a>.\nOther operations require the binary data to be stored in\nimmutable objects (\u201cread-only bytes-like objects\u201d); examples\nof these include <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> and a <a class=\"reference internal\" href=\"library/stdtypes.html#memoryview\" title=\"memoryview\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">memoryview</span></code></a>\nof a <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> object.</p>\n</dd>\n</main>\n"}, "bytecode": {"title": "bytecode", "body": "<main>\n<dd><p>Python source code is compiled into bytecode, the internal representation\nof a Python program in the CPython interpreter.  The bytecode is also\ncached in <code class=\"docutils literal notranslate\"><span class=\"pre\">.pyc</span></code> files so that executing the same file is\nfaster the second time (recompilation from source to bytecode can be\navoided).  This \u201cintermediate language\u201d is said to run on a\n<a class=\"reference internal\" href=\"#term-virtual-machine\"><span class=\"xref std std-term\">virtual machine</span></a> that executes the machine code corresponding to\neach bytecode. Do note that bytecodes are not expected to work between\ndifferent Python virtual machines, nor to be stable between Python\nreleases.</p>\n<p>A list of bytecode instructions can be found in the documentation for\n<a class=\"reference internal\" href=\"library/dis.html#bytecodes\"><span class=\"std std-ref\">the dis module</span></a>.</p>\n</dd>\n</main>\n"}, "callable": {"title": "callable", "body": "<main>\n<dd><p>A callable is an object that can be called, possibly with a set\nof arguments (see <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>), with the following syntax:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"nb\">callable</span><span class=\"p\">(</span><span class=\"n\">argument1</span><span class=\"p\">,</span> <span class=\"n\">argument2</span><span class=\"p\">,</span> <span class=\"n\">argumentN</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<p>A <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a>, and by extension a <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">method</span></a>, is a callable.\nAn instance of a class that implements the <a class=\"reference internal\" href=\"reference/datamodel.html#object.__call__\" title=\"object.__call__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__call__()</span></code></a>\nmethod is also a callable.</p>\n</dd>\n</main>\n"}, "callback": {"title": "callback", "body": "<main>\n<dd><p>A subroutine function which is passed as an argument to be executed at\nsome point in the future.</p>\n</dd>\n</main>\n"}, "class": {"title": "class", "body": "<main>\n<dd><p>A template for creating user-defined objects. Class definitions\nnormally contain method definitions which operate on instances of the\nclass.</p>\n</dd>\n</main>\n"}, "class variable": {"title": "class variable", "body": "<main>\n<dd><p>A variable defined in a class and intended to be modified only at\nclass level (i.e., not in an instance of the class).</p>\n</dd>\n</main>\n"}, "complex number": {"title": "complex number", "body": "<main>\n<dd><p>An extension of the familiar real number system in which all numbers are\nexpressed as a sum of a real part and an imaginary part.  Imaginary\nnumbers are real multiples of the imaginary unit (the square root of\n<code class=\"docutils literal notranslate\"><span class=\"pre\">-1</span></code>), often written <code class=\"docutils literal notranslate\"><span class=\"pre\">i</span></code> in mathematics or <code class=\"docutils literal notranslate\"><span class=\"pre\">j</span></code> in\nengineering.  Python has built-in support for complex numbers, which are\nwritten with this latter notation; the imaginary part is written with a\n<code class=\"docutils literal notranslate\"><span class=\"pre\">j</span></code> suffix, e.g., <code class=\"docutils literal notranslate\"><span class=\"pre\">3+1j</span></code>.  To get access to complex equivalents of the\n<a class=\"reference internal\" href=\"library/math.html#module-math\" title=\"math: Mathematical functions (sin() etc.).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">math</span></code></a> module, use <a class=\"reference internal\" href=\"library/cmath.html#module-cmath\" title=\"cmath: Mathematical functions for complex numbers.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">cmath</span></code></a>.  Use of complex numbers is a fairly\nadvanced mathematical feature.  If you\u2019re not aware of a need for them,\nit\u2019s almost certain you can safely ignore them.</p>\n</dd>\n</main>\n"}, "context manager": {"title": "context manager", "body": "<main>\n<dd><p>An object which controls the environment seen in a <a class=\"reference internal\" href=\"reference/compound_stmts.html#with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">with</span></code></a>\nstatement by defining <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__enter__()</span></code> and <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__exit__()</span></code> methods.\nSee <span class=\"target\" id=\"index-9\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0343/\"><strong>PEP 343</strong></a>.</p>\n</dd>\n</main>\n"}, "context variable": {"title": "context variable", "body": "<main>\n<dd><p>A variable which can have different values depending on its context.\nThis is similar to Thread-Local Storage in which each execution\nthread may have a different value for a variable. However, with context\nvariables, there may be several contexts in one execution thread and the\nmain usage for context variables is to keep track of variables in\nconcurrent asynchronous tasks.\nSee <a class=\"reference internal\" href=\"library/contextvars.html#module-contextvars\" title=\"contextvars: Context Variables\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">contextvars</span></code></a>.</p>\n</dd>\n</main>\n"}, "contiguous": {"title": "contiguous", "body": "<main>\n<dd><p id=\"index-10\">A buffer is considered contiguous exactly if it is either\n<em>C-contiguous</em> or <em>Fortran contiguous</em>.  Zero-dimensional buffers are\nC and Fortran contiguous.  In one-dimensional arrays, the items\nmust be laid out in memory next to each other, in order of\nincreasing indexes starting from zero.  In multidimensional\nC-contiguous arrays, the last index varies the fastest when\nvisiting items in order of memory address.  However, in\nFortran contiguous arrays, the first index varies the fastest.</p>\n</dd>\n</main>\n"}, "coroutine": {"title": "coroutine", "body": "<main>\n<dd><p>Coroutines are a more generalized form of subroutines. Subroutines are\nentered at one point and exited at another point.  Coroutines can be\nentered, exited, and resumed at many different points.  They can be\nimplemented with the <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-def\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code></a> statement.  See also\n<span class=\"target\" id=\"index-11\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "coroutine function": {"title": "coroutine function", "body": "<main>\n<dd><p>A function which returns a <a class=\"reference internal\" href=\"#term-coroutine\"><span class=\"xref std std-term\">coroutine</span></a> object.  A coroutine\nfunction may be defined with the <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-def\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">def</span></code></a> statement,\nand may contain <a class=\"reference internal\" href=\"reference/expressions.html#await\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">await</span></code></a>, <a class=\"reference internal\" href=\"reference/compound_stmts.html#async-for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">for</span></code></a>, and\n<a class=\"reference internal\" href=\"reference/compound_stmts.html#async-with\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">async</span> <span class=\"pre\">with</span></code></a> keywords.  These were introduced\nby <span class=\"target\" id=\"index-12\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0492/\"><strong>PEP 492</strong></a>.</p>\n</dd>\n</main>\n"}, "cpython": {"title": "CPython", "body": "<main>\n<dd><p>The canonical implementation of the Python programming language, as\ndistributed on <a class=\"reference external\" href=\"https://www.python.org\">python.org</a>.  The term \u201cCPython\u201d\nis used when necessary to distinguish this implementation from others\nsuch as Jython or IronPython.</p>\n</dd>\n</main>\n"}, "decorator": {"title": "decorator", "body": "<main>\n<dd><p>A function returning another function, usually applied as a function\ntransformation using the <code class=\"docutils literal notranslate\"><span class=\"pre\">&#64;wrapper</span></code> syntax.  Common examples for\ndecorators are <a class=\"reference internal\" href=\"library/functions.html#classmethod\" title=\"classmethod\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">classmethod()</span></code></a> and <a class=\"reference internal\" href=\"library/functions.html#staticmethod\" title=\"staticmethod\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">staticmethod()</span></code></a>.</p>\n<p>The decorator syntax is merely syntactic sugar, the following two\nfunction definitions are semantically equivalent:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"nb\">staticmethod</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@staticmethod</span>\n<span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n</pre></div>\n</div>\n<p>The same concept exists for classes, but is less commonly used there.  See\nthe documentation for <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">function definitions</span></a> and\n<a class=\"reference internal\" href=\"reference/compound_stmts.html#class\"><span class=\"std std-ref\">class definitions</span></a> for more about decorators.</p>\n</dd>\n</main>\n"}, "descriptor": {"title": "descriptor", "body": "<main>\n<dd><p>Any object which defines the methods <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__get__()</span></code>, <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__set__()</span></code>, or\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__delete__()</span></code>.  When a class attribute is a descriptor, its special\nbinding behavior is triggered upon attribute lookup.  Normally, using\n<em>a.b</em> to get, set or delete an attribute looks up the object named <em>b</em> in\nthe class dictionary for <em>a</em>, but if <em>b</em> is a descriptor, the respective\ndescriptor method gets called.  Understanding descriptors is a key to a\ndeep understanding of Python because they are the basis for many features\nincluding functions, methods, properties, class methods, static methods,\nand reference to super classes.</p>\n<p>For more information about descriptors\u2019 methods, see <a class=\"reference internal\" href=\"reference/datamodel.html#descriptors\"><span class=\"std std-ref\">Implementing Descriptors</span></a>\nor the <a class=\"reference internal\" href=\"howto/descriptor.html#descriptorhowto\"><span class=\"std std-ref\">Descriptor How To Guide</span></a>.</p>\n</dd>\n</main>\n"}, "dictionary": {"title": "dictionary", "body": "<main>\n<dd><p>An associative array, where arbitrary keys are mapped to values.  The\nkeys can be any object with <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__hash__()</span></code> and <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__eq__()</span></code> methods.\nCalled a hash in Perl.</p>\n</dd>\n</main>\n"}, "dictionary comprehension": {"title": "dictionary comprehension", "body": "<main>\n<dd><p>A compact way to process all or part of the elements in an iterable and\nreturn a dictionary with the results. <code class=\"docutils literal notranslate\"><span class=\"pre\">results</span> <span class=\"pre\">=</span> <span class=\"pre\">{n:</span> <span class=\"pre\">n</span> <span class=\"pre\">**</span> <span class=\"pre\">2</span> <span class=\"pre\">for</span> <span class=\"pre\">n</span> <span class=\"pre\">in</span>\n<span class=\"pre\">range(10)}</span></code> generates a dictionary containing key <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span></code> mapped to\nvalue <code class=\"docutils literal notranslate\"><span class=\"pre\">n</span> <span class=\"pre\">**</span> <span class=\"pre\">2</span></code>. See <a class=\"reference internal\" href=\"reference/expressions.html#comprehensions\"><span class=\"std std-ref\">Displays for lists, sets and dictionaries</span></a>.</p>\n</dd>\n</main>\n"}, "dictionary view": {"title": "dictionary view", "body": "<main>\n<dd><p>The objects returned from <a class=\"reference internal\" href=\"library/stdtypes.html#dict.keys\" title=\"dict.keys\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">dict.keys()</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#dict.values\" title=\"dict.values\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">dict.values()</span></code></a>, and\n<a class=\"reference internal\" href=\"library/stdtypes.html#dict.items\" title=\"dict.items\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">dict.items()</span></code></a> are called dictionary views. They provide a dynamic\nview on the dictionary\u2019s entries, which means that when the dictionary\nchanges, the view reflects these changes. To force the\ndictionary view to become a full list use <code class=\"docutils literal notranslate\"><span class=\"pre\">list(dictview)</span></code>.  See\n<a class=\"reference internal\" href=\"library/stdtypes.html#dict-views\"><span class=\"std std-ref\">Dictionary view objects</span></a>.</p>\n</dd>\n</main>\n"}, "docstring": {"title": "docstring", "body": "<main>\n<dd><p>A string literal which appears as the first expression in a class,\nfunction or module.  While ignored when the suite is executed, it is\nrecognized by the compiler and put into the <code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__doc__</span></code> attribute\nof the enclosing class, function or module.  Since it is available via\nintrospection, it is the canonical place for documentation of the\nobject.</p>\n</dd>\n</main>\n"}, "duck-typing": {"title": "duck-typing", "body": "<main>\n<dd><p>A programming style which does not look at an object\u2019s type to determine\nif it has the right interface; instead, the method or attribute is simply\ncalled or used (\u201cIf it looks like a duck and quacks like a duck, it\nmust be a duck.\u201d)  By emphasizing interfaces rather than specific types,\nwell-designed code improves its flexibility by allowing polymorphic\nsubstitution.  Duck-typing avoids tests using <a class=\"reference internal\" href=\"library/functions.html#type\" title=\"type\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">type()</span></code></a> or\n<a class=\"reference internal\" href=\"library/functions.html#isinstance\" title=\"isinstance\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">isinstance()</span></code></a>.  (Note, however, that duck-typing can be complemented\nwith <a class=\"reference internal\" href=\"#term-abstract-base-class\"><span class=\"xref std std-term\">abstract base classes</span></a>.)  Instead, it\ntypically employs <a class=\"reference internal\" href=\"library/functions.html#hasattr\" title=\"hasattr\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">hasattr()</span></code></a> tests or <a class=\"reference internal\" href=\"#term-EAFP\"><span class=\"xref std std-term\">EAFP</span></a> programming.</p>\n</dd>\n</main>\n"}, "eafp": {"title": "EAFP", "body": "<main>\n<dd><p>Easier to ask for forgiveness than permission.  This common Python coding\nstyle assumes the existence of valid keys or attributes and catches\nexceptions if the assumption proves false.  This clean and fast style is\ncharacterized by the presence of many <a class=\"reference internal\" href=\"reference/compound_stmts.html#try\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">try</span></code></a> and <a class=\"reference internal\" href=\"reference/compound_stmts.html#except\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">except</span></code></a>\nstatements.  The technique contrasts with the <a class=\"reference internal\" href=\"#term-LBYL\"><span class=\"xref std std-term\">LBYL</span></a> style\ncommon to many other languages such as C.</p>\n</dd>\n</main>\n"}, "expression": {"title": "expression", "body": "<main>\n<dd><p>A piece of syntax which can be evaluated to some value.  In other words,\nan expression is an accumulation of expression elements like literals,\nnames, attribute access, operators or function calls which all return a\nvalue.  In contrast to many other languages, not all language constructs\nare expressions.  There are also <a class=\"reference internal\" href=\"#term-statement\"><span class=\"xref std std-term\">statement</span></a>s which cannot be used\nas expressions, such as <a class=\"reference internal\" href=\"reference/compound_stmts.html#while\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">while</span></code></a>.  Assignments are also statements,\nnot expressions.</p>\n</dd>\n</main>\n"}, "extension module": {"title": "extension module", "body": "<main>\n<dd><p>A module written in C or C++, using Python\u2019s C API to interact with the\ncore and with user code.</p>\n</dd>\n</main>\n"}, "f-string": {"title": "f-string", "body": "<main>\n<dd><p>String literals prefixed with <code class=\"docutils literal notranslate\"><span class=\"pre\">'f'</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">'F'</span></code> are commonly called\n\u201cf-strings\u201d which is short for\n<a class=\"reference internal\" href=\"reference/lexical_analysis.html#f-strings\"><span class=\"std std-ref\">formatted string literals</span></a>.  See also <span class=\"target\" id=\"index-13\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0498/\"><strong>PEP 498</strong></a>.</p>\n</dd>\n</main>\n"}, "file object": {"title": "file object", "body": "<main>\n<dd><p>An object exposing a file-oriented API (with methods such as\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">read()</span></code> or <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">write()</span></code>) to an underlying resource.  Depending\non the way it was created, a file object can mediate access to a real\non-disk file or to another type of storage or communication device\n(for example standard input/output, in-memory buffers, sockets, pipes,\netc.).  File objects are also called <em class=\"dfn\">file-like objects</em> or\n<em class=\"dfn\">streams</em>.</p>\n<p>There are actually three categories of file objects: raw\n<a class=\"reference internal\" href=\"#term-binary-file\"><span class=\"xref std std-term\">binary files</span></a>, buffered\n<a class=\"reference internal\" href=\"#term-binary-file\"><span class=\"xref std std-term\">binary files</span></a> and <a class=\"reference internal\" href=\"#term-text-file\"><span class=\"xref std std-term\">text files</span></a>.\nTheir interfaces are defined in the <a class=\"reference internal\" href=\"library/io.html#module-io\" title=\"io: Core tools for working with streams.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">io</span></code></a> module.  The canonical\nway to create a file object is by using the <a class=\"reference internal\" href=\"library/functions.html#open\" title=\"open\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">open()</span></code></a> function.</p>\n</dd>\n</main>\n"}, "file-like object": {"title": "file-like object", "body": "<main>\n<dd><p>A synonym for <a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file object</span></a>.</p>\n</dd>\n</main>\n"}, "filesystem encoding and error handler": {"title": "filesystem encoding and error handler", "body": "<main>\n<dd><p>Encoding and error handler used by Python to decode bytes from the\noperating system and encode Unicode to the operating system.</p>\n<p>The filesystem encoding must guarantee to successfully decode all bytes\nbelow 128. If the file system encoding fails to provide this guarantee,\nAPI functions can raise <a class=\"reference internal\" href=\"library/exceptions.html#UnicodeError\" title=\"UnicodeError\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">UnicodeError</span></code></a>.</p>\n<p>The <a class=\"reference internal\" href=\"library/sys.html#sys.getfilesystemencoding\" title=\"sys.getfilesystemencoding\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys.getfilesystemencoding()</span></code></a> and\n<a class=\"reference internal\" href=\"library/sys.html#sys.getfilesystemencodeerrors\" title=\"sys.getfilesystemencodeerrors\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys.getfilesystemencodeerrors()</span></code></a> functions can be used to get the\nfilesystem encoding and error handler.</p>\n<p>The <a class=\"reference internal\" href=\"#term-filesystem-encoding-and-error-handler\"><span class=\"xref std std-term\">filesystem encoding and error handler</span></a> are configured at\nPython startup by the <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig_Read\" title=\"PyConfig_Read\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">PyConfig_Read()</span></code></a> function: see\n<a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig.filesystem_encoding\" title=\"PyConfig.filesystem_encoding\"><code class=\"xref c c-member docutils literal notranslate\"><span class=\"pre\">filesystem_encoding</span></code></a> and\n<a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig.filesystem_errors\" title=\"PyConfig.filesystem_errors\"><code class=\"xref c c-member docutils literal notranslate\"><span class=\"pre\">filesystem_errors</span></code></a> members of <a class=\"reference internal\" href=\"c-api/init_config.html#c.PyConfig\" title=\"PyConfig\"><code class=\"xref c c-type docutils literal notranslate\"><span class=\"pre\">PyConfig</span></code></a>.</p>\n<p>See also the <a class=\"reference internal\" href=\"#term-locale-encoding\"><span class=\"xref std std-term\">locale encoding</span></a>.</p>\n</dd>\n</main>\n"}, "finder": {"title": "finder", "body": "<main>\n<dd><p>An object that tries to find the <a class=\"reference internal\" href=\"#term-loader\"><span class=\"xref std std-term\">loader</span></a> for a module that is\nbeing imported.</p>\n<p>Since Python 3.3, there are two types of finder: <a class=\"reference internal\" href=\"#term-meta-path-finder\"><span class=\"xref std std-term\">meta path finders</span></a> for use with <a class=\"reference internal\" href=\"library/sys.html#sys.meta_path\" title=\"sys.meta_path\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.meta_path</span></code></a>, and <a class=\"reference internal\" href=\"#term-path-entry-finder\"><span class=\"xref std std-term\">path\nentry finders</span></a> for use with <a class=\"reference internal\" href=\"library/sys.html#sys.path_hooks\" title=\"sys.path_hooks\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path_hooks</span></code></a>.</p>\n<p>See <span class=\"target\" id=\"index-14\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0302/\"><strong>PEP 302</strong></a>, <span class=\"target\" id=\"index-15\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0420/\"><strong>PEP 420</strong></a> and <span class=\"target\" id=\"index-16\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0451/\"><strong>PEP 451</strong></a> for much more detail.</p>\n</dd>\n</main>\n"}, "floor division": {"title": "floor division", "body": "<main>\n<dd><p>Mathematical division that rounds down to nearest integer.  The floor\ndivision operator is <code class=\"docutils literal notranslate\"><span class=\"pre\">//</span></code>.  For example, the expression <code class=\"docutils literal notranslate\"><span class=\"pre\">11</span> <span class=\"pre\">//</span> <span class=\"pre\">4</span></code>\nevaluates to <code class=\"docutils literal notranslate\"><span class=\"pre\">2</span></code> in contrast to the <code class=\"docutils literal notranslate\"><span class=\"pre\">2.75</span></code> returned by float true\ndivision.  Note that <code class=\"docutils literal notranslate\"><span class=\"pre\">(-11)</span> <span class=\"pre\">//</span> <span class=\"pre\">4</span></code> is <code class=\"docutils literal notranslate\"><span class=\"pre\">-3</span></code> because that is <code class=\"docutils literal notranslate\"><span class=\"pre\">-2.75</span></code>\nrounded <em>downward</em>. See <span class=\"target\" id=\"index-17\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0238/\"><strong>PEP 238</strong></a>.</p>\n</dd>\n</main>\n"}, "function": {"title": "function", "body": "<main>\n<dd><p>A series of statements which returns some value to a caller. It can also\nbe passed zero or more <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">arguments</span></a> which may be used in\nthe execution of the body. See also <a class=\"reference internal\" href=\"#term-parameter\"><span class=\"xref std std-term\">parameter</span></a>, <a class=\"reference internal\" href=\"#term-method\"><span class=\"xref std std-term\">method</span></a>,\nand the <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">Function definitions</span></a> section.</p>\n</dd>\n</main>\n"}, "function annotation": {"title": "function annotation", "body": "<main>\n<dd><p>An <a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotation</span></a> of a function parameter or return value.</p>\n<p>Function annotations are usually used for\n<a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hints</span></a>: for example, this function is expected to take two\n<a class=\"reference internal\" href=\"library/functions.html#int\" title=\"int\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">int</span></code></a> arguments and is also expected to have an <a class=\"reference internal\" href=\"library/functions.html#int\" title=\"int\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">int</span></code></a>\nreturn value:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">sum_two_numbers</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n   <span class=\"k\">return</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n</pre></div>\n</div>\n<p>Function annotation syntax is explained in section <a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">Function definitions</span></a>.</p>\n<p>See <a class=\"reference internal\" href=\"#term-variable-annotation\"><span class=\"xref std std-term\">variable annotation</span></a> and <span class=\"target\" id=\"index-18\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>,\nwhich describe this functionality.\nAlso see <a class=\"reference internal\" href=\"howto/annotations.html#annotations-howto\"><span class=\"std std-ref\">Annotations Best Practices</span></a>\nfor best practices on working with annotations.</p>\n</dd>\n</main>\n"}, "__future__": {"title": "__future__", "body": "<main>\n<dd><p>A <a class=\"reference internal\" href=\"reference/simple_stmts.html#future\"><span class=\"std std-ref\">future statement</span></a>, <code class=\"docutils literal notranslate\"><span class=\"pre\">from</span> <span class=\"pre\">__future__</span> <span class=\"pre\">import</span> <span class=\"pre\">&lt;feature&gt;</span></code>,\ndirects the compiler to compile the current module using syntax or\nsemantics that will become standard in a future release of Python.\nThe <a class=\"reference internal\" href=\"library/__future__.html#module-__future__\" title=\"__future__: Future statement definitions\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">__future__</span></code></a> module documents the possible values of\n<em>feature</em>.  By importing this module and evaluating its variables,\nyou can see when a new feature was first added to the language and\nwhen it will (or did) become the default:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">__future__</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">__future__</span><span class=\"o\">.</span><span class=\"n\">division</span>\n<span class=\"go\">_Feature((2, 2, 0, &#39;alpha&#39;, 2), (3, 0, 0, &#39;alpha&#39;, 0), 8192)</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "garbage collection": {"title": "garbage collection", "body": "<main>\n<dd><p>The process of freeing memory when it is not used anymore.  Python\nperforms garbage collection via reference counting and a cyclic garbage\ncollector that is able to detect and break reference cycles.  The\ngarbage collector can be controlled using the <a class=\"reference internal\" href=\"library/gc.html#module-gc\" title=\"gc: Interface to the cycle-detecting garbage collector.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">gc</span></code></a> module.</p>\n</dd>\n</main>\n"}, "generator": {"title": "generator", "body": "<main>\n<dd><p>A function which returns a <a class=\"reference internal\" href=\"#term-generator-iterator\"><span class=\"xref std std-term\">generator iterator</span></a>.  It looks like a\nnormal function except that it contains <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> expressions\nfor producing a series of values usable in a for-loop or that can be\nretrieved one at a time with the <a class=\"reference internal\" href=\"library/functions.html#next\" title=\"next\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">next()</span></code></a> function.</p>\n<p>Usually refers to a generator function, but may refer to a\n<em>generator iterator</em> in some contexts.  In cases where the intended\nmeaning isn\u2019t clear, using the full terms avoids ambiguity.</p>\n</dd>\n</main>\n"}, "generator iterator": {"title": "generator iterator", "body": "<main>\n<dd><p>An object created by a <a class=\"reference internal\" href=\"#term-generator\"><span class=\"xref std std-term\">generator</span></a> function.</p>\n<p>Each <a class=\"reference internal\" href=\"reference/simple_stmts.html#yield\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">yield</span></code></a> temporarily suspends processing, remembering the\nlocation execution state (including local variables and pending\ntry-statements).  When the <em>generator iterator</em> resumes, it picks up where\nit left off (in contrast to functions which start fresh on every\ninvocation).</p>\n</dd>\n</main>\n"}, "generator expression": {"title": "generator expression", "body": "<main>\n<dd><p>An expression that returns an iterator.  It looks like a normal expression\nfollowed by a <code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code> clause defining a loop variable, range,\nand an optional <code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code> clause.  The combined expression\ngenerates values for an enclosing function:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">*</span><span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">))</span>         <span class=\"c1\"># sum of squares 0, 1, 4, ... 81</span>\n<span class=\"go\">285</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "generic function": {"title": "generic function", "body": "<main>\n<dd><p>A function composed of multiple functions implementing the same operation\nfor different types. Which implementation should be used during a call is\ndetermined by the dispatch algorithm.</p>\n<p>See also the <a class=\"reference internal\" href=\"#term-single-dispatch\"><span class=\"xref std std-term\">single dispatch</span></a> glossary entry, the\n<a class=\"reference internal\" href=\"library/functools.html#functools.singledispatch\" title=\"functools.singledispatch\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">functools.singledispatch()</span></code></a> decorator, and <span class=\"target\" id=\"index-21\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0443/\"><strong>PEP 443</strong></a>.</p>\n</dd>\n</main>\n"}, "generic type": {"title": "generic type", "body": "<main>\n<dd><p>A <a class=\"reference internal\" href=\"#term-type\"><span class=\"xref std std-term\">type</span></a> that can be parameterized; typically a\n<a class=\"reference internal\" href=\"reference/datamodel.html#sequence-types\"><span class=\"std std-ref\">container class</span></a> such as <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a> or\n<a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>. Used for <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hints</span></a> and\n<a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotations</span></a>.</p>\n<p>For more details, see <a class=\"reference internal\" href=\"library/stdtypes.html#types-genericalias\"><span class=\"std std-ref\">generic alias types</span></a>,\n<span class=\"target\" id=\"index-22\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0483/\"><strong>PEP 483</strong></a>, <span class=\"target\" id=\"index-23\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, <span class=\"target\" id=\"index-24\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0585/\"><strong>PEP 585</strong></a>, and the <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a> module.</p>\n</dd>\n</main>\n"}, "gil": {"title": "GIL", "body": "<main>\n<dd><p>See <a class=\"reference internal\" href=\"#term-global-interpreter-lock\"><span class=\"xref std std-term\">global interpreter lock</span></a>.</p>\n</dd>\n</main>\n"}, "global interpreter lock": {"title": "global interpreter lock", "body": "<main>\n<dd><p>The mechanism used by the <a class=\"reference internal\" href=\"#term-CPython\"><span class=\"xref std std-term\">CPython</span></a> interpreter to assure that\nonly one thread executes Python <a class=\"reference internal\" href=\"#term-bytecode\"><span class=\"xref std std-term\">bytecode</span></a> at a time.\nThis simplifies the CPython implementation by making the object model\n(including critical built-in types such as <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>) implicitly\nsafe against concurrent access.  Locking the entire interpreter\nmakes it easier for the interpreter to be multi-threaded, at the\nexpense of much of the parallelism afforded by multi-processor\nmachines.</p>\n<p>However, some extension modules, either standard or third-party,\nare designed so as to release the GIL when doing computationally intensive\ntasks such as compression or hashing.  Also, the GIL is always released\nwhen doing I/O.</p>\n<p>Past efforts to create a \u201cfree-threaded\u201d interpreter (one which locks\nshared data at a much finer granularity) have not been successful\nbecause performance suffered in the common single-processor case. It\nis believed that overcoming this performance issue would make the\nimplementation much more complicated and therefore costlier to maintain.</p>\n</dd>\n</main>\n"}, "hash-based pyc": {"title": "hash-based pyc", "body": "<main>\n<dd><p>A bytecode cache file that uses the hash rather than the last-modified\ntime of the corresponding source file to determine its validity. See\n<a class=\"reference internal\" href=\"reference/import.html#pyc-invalidation\"><span class=\"std std-ref\">Cached bytecode invalidation</span></a>.</p>\n</dd>\n</main>\n"}, "hashable": {"title": "hashable", "body": "<main>\n<dd><p>An object is <em>hashable</em> if it has a hash value which never changes during\nits lifetime (it needs a <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__hash__()</span></code> method), and can be compared to\nother objects (it needs an <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__eq__()</span></code> method).  Hashable objects which\ncompare equal must have the same hash value.</p>\n<p>Hashability makes an object usable as a dictionary key and a set member,\nbecause these data structures use the hash value internally.</p>\n<p>Most of Python\u2019s immutable built-in objects are hashable; mutable\ncontainers (such as lists or dictionaries) are not; immutable\ncontainers (such as tuples and frozensets) are only hashable if\ntheir elements are hashable.  Objects which are\ninstances of user-defined classes are hashable by default.  They all\ncompare unequal (except with themselves), and their hash value is derived\nfrom their <a class=\"reference internal\" href=\"library/functions.html#id\" title=\"id\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">id()</span></code></a>.</p>\n</dd>\n</main>\n"}, "idle": {"title": "IDLE", "body": "<main>\n<dd><p>An Integrated Development and Learning Environment for Python.\n<a class=\"reference internal\" href=\"library/idle.html#idle\"><span class=\"std std-ref\">IDLE</span></a> is a basic editor and interpreter environment\nwhich ships with the standard distribution of Python.</p>\n</dd>\n</main>\n"}, "immutable": {"title": "immutable", "body": "<main>\n<dd><p>An object with a fixed value.  Immutable objects include numbers, strings and\ntuples.  Such an object cannot be altered.  A new object has to\nbe created if a different value has to be stored.  They play an important\nrole in places where a constant hash value is needed, for example as a key\nin a dictionary.</p>\n</dd>\n</main>\n"}, "import path": {"title": "import path", "body": "<main>\n<dd><p>A list of locations (or <a class=\"reference internal\" href=\"#term-path-entry\"><span class=\"xref std std-term\">path entries</span></a>) that are\nsearched by the <a class=\"reference internal\" href=\"#term-path-based-finder\"><span class=\"xref std std-term\">path based finder</span></a> for modules to import. During\nimport, this list of locations usually comes from <a class=\"reference internal\" href=\"library/sys.html#sys.path\" title=\"sys.path\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path</span></code></a>, but\nfor subpackages it may also come from the parent package\u2019s <code class=\"docutils literal notranslate\"><span class=\"pre\">__path__</span></code>\nattribute.</p>\n</dd>\n</main>\n"}, "importing": {"title": "importing", "body": "<main>\n<dd><p>The process by which Python code in one module is made available to\nPython code in another module.</p>\n</dd>\n</main>\n"}, "importer": {"title": "importer", "body": "<main>\n<dd><p>An object that both finds and loads a module; both a\n<a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">finder</span></a> and <a class=\"reference internal\" href=\"#term-loader\"><span class=\"xref std std-term\">loader</span></a> object.</p>\n</dd>\n</main>\n"}, "interactive": {"title": "interactive", "body": "<main>\n<dd><p>Python has an interactive interpreter which means you can enter\nstatements and expressions at the interpreter prompt, immediately\nexecute them and see their results.  Just launch <code class=\"docutils literal notranslate\"><span class=\"pre\">python</span></code> with no\narguments (possibly by selecting it from your computer\u2019s main\nmenu). It is a very powerful way to test out new ideas or inspect\nmodules and packages (remember <code class=\"docutils literal notranslate\"><span class=\"pre\">help(x)</span></code>).</p>\n</dd>\n</main>\n"}, "interpreted": {"title": "interpreted", "body": "<main>\n<dd><p>Python is an interpreted language, as opposed to a compiled one,\nthough the distinction can be blurry because of the presence of the\nbytecode compiler.  This means that source files can be run directly\nwithout explicitly creating an executable which is then run.\nInterpreted languages typically have a shorter development/debug cycle\nthan compiled ones, though their programs generally also run more\nslowly.  See also <a class=\"reference internal\" href=\"#term-interactive\"><span class=\"xref std std-term\">interactive</span></a>.</p>\n</dd>\n</main>\n"}, "interpreter shutdown": {"title": "interpreter shutdown", "body": "<main>\n<dd><p>When asked to shut down, the Python interpreter enters a special phase\nwhere it gradually releases all allocated resources, such as modules\nand various critical internal structures.  It also makes several calls\nto the <a class=\"reference internal\" href=\"#term-garbage-collection\"><span class=\"xref std std-term\">garbage collector</span></a>. This can trigger\nthe execution of code in user-defined destructors or weakref callbacks.\nCode executed during the shutdown phase can encounter various\nexceptions as the resources it relies on may not function anymore\n(common examples are library modules or the warnings machinery).</p>\n<p>The main reason for interpreter shutdown is that the <code class=\"docutils literal notranslate\"><span class=\"pre\">__main__</span></code> module\nor the script being run has finished executing.</p>\n</dd>\n</main>\n"}, "iterable": {"title": "iterable", "body": "<main>\n<dd><p>An object capable of returning its members one at a time. Examples of\niterables include all sequence types (such as <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>,\nand <a class=\"reference internal\" href=\"library/stdtypes.html#tuple\" title=\"tuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tuple</span></code></a>) and some non-sequence types like <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>,\n<a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file objects</span></a>, and objects of any classes you define\nwith an <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__iter__()</span></code> method or with a <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code> method\nthat implements <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a> semantics.</p>\n<p>Iterables can be\nused in a <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a> loop and in many other places where a sequence is\nneeded (<a class=\"reference internal\" href=\"library/functions.html#zip\" title=\"zip\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">zip()</span></code></a>, <a class=\"reference internal\" href=\"library/functions.html#map\" title=\"map\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">map()</span></code></a>, \u2026).  When an iterable object is passed\nas an argument to the built-in function <a class=\"reference internal\" href=\"library/functions.html#iter\" title=\"iter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter()</span></code></a>, it returns an\niterator for the object.  This iterator is good for one pass over the set\nof values.  When using iterables, it is usually not necessary to call\n<a class=\"reference internal\" href=\"library/functions.html#iter\" title=\"iter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter()</span></code></a> or deal with iterator objects yourself.  The <code class=\"docutils literal notranslate\"><span class=\"pre\">for</span></code>\nstatement does that automatically for you, creating a temporary unnamed\nvariable to hold the iterator for the duration of the loop.  See also\n<a class=\"reference internal\" href=\"#term-iterator\"><span class=\"xref std std-term\">iterator</span></a>, <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a>, and <a class=\"reference internal\" href=\"#term-generator\"><span class=\"xref std std-term\">generator</span></a>.</p>\n</dd>\n</main>\n"}, "iterator": {"title": "iterator", "body": "<main>\n<dd><p>An object representing a stream of data.  Repeated calls to the iterator\u2019s\n<a class=\"reference internal\" href=\"library/stdtypes.html#iterator.__next__\" title=\"iterator.__next__\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__next__()</span></code></a> method (or passing it to the built-in function\n<a class=\"reference internal\" href=\"library/functions.html#next\" title=\"next\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">next()</span></code></a>) return successive items in the stream.  When no more data\nare available a <a class=\"reference internal\" href=\"library/exceptions.html#StopIteration\" title=\"StopIteration\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">StopIteration</span></code></a> exception is raised instead.  At this\npoint, the iterator object is exhausted and any further calls to its\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__next__()</span></code> method just raise <a class=\"reference internal\" href=\"library/exceptions.html#StopIteration\" title=\"StopIteration\"><code class=\"xref py py-exc docutils literal notranslate\"><span class=\"pre\">StopIteration</span></code></a> again.  Iterators\nare required to have an <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__iter__()</span></code> method that returns the iterator\nobject itself so every iterator is also iterable and may be used in most\nplaces where other iterables are accepted.  One notable exception is code\nwhich attempts multiple iteration passes.  A container object (such as a\n<a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a>) produces a fresh new iterator each time you pass it to the\n<a class=\"reference internal\" href=\"library/functions.html#iter\" title=\"iter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">iter()</span></code></a> function or use it in a <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a> loop.  Attempting this\nwith an iterator will just return the same exhausted iterator object used\nin the previous iteration pass, making it appear like an empty container.</p>\n<p>More information can be found in <a class=\"reference internal\" href=\"library/stdtypes.html#typeiter\"><span class=\"std std-ref\">Iterator Types</span></a>.</p>\n<div class=\"impl-detail compound\">\n<p><strong>CPython implementation detail:</strong> CPython does not consistently apply the requirement that an iterator\ndefine <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__iter__()</span></code>.</p>\n</div>\n</dd>\n</main>\n"}, "key function": {"title": "key function", "body": "<main>\n<dd><p>A key function or collation function is a callable that returns a value\nused for sorting or ordering.  For example, <a class=\"reference internal\" href=\"library/locale.html#locale.strxfrm\" title=\"locale.strxfrm\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">locale.strxfrm()</span></code></a> is\nused to produce a sort key that is aware of locale specific sort\nconventions.</p>\n<p>A number of tools in Python accept key functions to control how elements\nare ordered or grouped.  They include <a class=\"reference internal\" href=\"library/functions.html#min\" title=\"min\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">min()</span></code></a>, <a class=\"reference internal\" href=\"library/functions.html#max\" title=\"max\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">max()</span></code></a>,\n<a class=\"reference internal\" href=\"library/functions.html#sorted\" title=\"sorted\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sorted()</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#list.sort\" title=\"list.sort\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">list.sort()</span></code></a>, <a class=\"reference internal\" href=\"library/heapq.html#heapq.merge\" title=\"heapq.merge\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">heapq.merge()</span></code></a>,\n<a class=\"reference internal\" href=\"library/heapq.html#heapq.nsmallest\" title=\"heapq.nsmallest\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">heapq.nsmallest()</span></code></a>, <a class=\"reference internal\" href=\"library/heapq.html#heapq.nlargest\" title=\"heapq.nlargest\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">heapq.nlargest()</span></code></a>, and\n<a class=\"reference internal\" href=\"library/itertools.html#itertools.groupby\" title=\"itertools.groupby\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">itertools.groupby()</span></code></a>.</p>\n<p>There are several ways to create a key function.  For example. the\n<a class=\"reference internal\" href=\"library/stdtypes.html#str.lower\" title=\"str.lower\"><code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">str.lower()</span></code></a> method can serve as a key function for case insensitive\nsorts.  Alternatively, a key function can be built from a\n<a class=\"reference internal\" href=\"reference/expressions.html#lambda\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">lambda</span></code></a> expression such as <code class=\"docutils literal notranslate\"><span class=\"pre\">lambda</span> <span class=\"pre\">r:</span> <span class=\"pre\">(r[0],</span> <span class=\"pre\">r[2])</span></code>.  Also,\n<a class=\"reference internal\" href=\"library/operator.html#operator.attrgetter\" title=\"operator.attrgetter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">operator.attrgetter()</span></code></a>, <a class=\"reference internal\" href=\"library/operator.html#operator.itemgetter\" title=\"operator.itemgetter\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">operator.itemgetter()</span></code></a>, and\n<a class=\"reference internal\" href=\"library/operator.html#operator.methodcaller\" title=\"operator.methodcaller\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">operator.methodcaller()</span></code></a> are three key function constructors.  See the <a class=\"reference internal\" href=\"howto/sorting.html#sortinghowto\"><span class=\"std std-ref\">Sorting HOW TO</span></a> for examples of how to create and use key functions.</p>\n</dd>\n</main>\n"}, "keyword argument": {"title": "keyword argument", "body": "<main>\n<dd><p>See <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>.</p>\n</dd>\n</main>\n"}, "lambda": {"title": "lambda", "body": "<main>\n<dd><p>An anonymous inline function consisting of a single <a class=\"reference internal\" href=\"#term-expression\"><span class=\"xref std std-term\">expression</span></a>\nwhich is evaluated when the function is called.  The syntax to create\na lambda function is <code class=\"docutils literal notranslate\"><span class=\"pre\">lambda</span> <span class=\"pre\">[parameters]:</span> <span class=\"pre\">expression</span></code></p>\n</dd>\n</main>\n"}, "lbyl": {"title": "LBYL", "body": "<main>\n<dd><p>Look before you leap.  This coding style explicitly tests for\npre-conditions before making calls or lookups.  This style contrasts with\nthe <a class=\"reference internal\" href=\"#term-EAFP\"><span class=\"xref std std-term\">EAFP</span></a> approach and is characterized by the presence of many\n<a class=\"reference internal\" href=\"reference/compound_stmts.html#if\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code></a> statements.</p>\n<p>In a multi-threaded environment, the LBYL approach can risk introducing a\nrace condition between \u201cthe looking\u201d and \u201cthe leaping\u201d.  For example, the\ncode, <code class=\"docutils literal notranslate\"><span class=\"pre\">if</span> <span class=\"pre\">key</span> <span class=\"pre\">in</span> <span class=\"pre\">mapping:</span> <span class=\"pre\">return</span> <span class=\"pre\">mapping[key]</span></code> can fail if another\nthread removes <em>key</em> from <em>mapping</em> after the test, but before the lookup.\nThis issue can be solved with locks or by using the EAFP approach.</p>\n</dd>\n</main>\n"}, "locale encoding": {"title": "locale encoding", "body": "<main>\n<dd><p>On Unix, it is the encoding of the LC_CTYPE locale. It can be set with\n<a class=\"reference internal\" href=\"library/locale.html#locale.setlocale\" title=\"locale.setlocale\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">locale.setlocale(locale.LC_CTYPE,</span> <span class=\"pre\">new_locale)</span></code></a>.</p>\n<p>On Windows, it is the ANSI code page (ex: <code class=\"docutils literal notranslate\"><span class=\"pre\">&quot;cp1252&quot;</span></code>).</p>\n<p>On Android and VxWorks, Python uses <code class=\"docutils literal notranslate\"><span class=\"pre\">&quot;utf-8&quot;</span></code> as the locale encoding.</p>\n<p><code class=\"docutils literal notranslate\"><span class=\"pre\">locale.getencoding()</span></code> can be used to get the locale encoding.</p>\n<p>See also the <a class=\"reference internal\" href=\"#term-filesystem-encoding-and-error-handler\"><span class=\"xref std std-term\">filesystem encoding and error handler</span></a>.</p>\n</dd>\n</main>\n"}, "list": {"title": "list", "body": "<main>\n<dd><p>A built-in Python <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a>.  Despite its name it is more akin\nto an array in other languages than to a linked list since access to\nelements is O(1).</p>\n</dd>\n</main>\n"}, "list comprehension": {"title": "list comprehension", "body": "<main>\n<dd><p>A compact way to process all or part of the elements in a sequence and\nreturn a list with the results.  <code class=\"docutils literal notranslate\"><span class=\"pre\">result</span> <span class=\"pre\">=</span> <span class=\"pre\">['{:#04x}'.format(x)</span> <span class=\"pre\">for</span> <span class=\"pre\">x</span> <span class=\"pre\">in</span>\n<span class=\"pre\">range(256)</span> <span class=\"pre\">if</span> <span class=\"pre\">x</span> <span class=\"pre\">%</span> <span class=\"pre\">2</span> <span class=\"pre\">==</span> <span class=\"pre\">0]</span></code> generates a list of strings containing\neven hex numbers (0x..) in the range from 0 to 255. The <a class=\"reference internal\" href=\"reference/compound_stmts.html#if\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code></a>\nclause is optional.  If omitted, all elements in <code class=\"docutils literal notranslate\"><span class=\"pre\">range(256)</span></code> are\nprocessed.</p>\n</dd>\n</main>\n"}, "loader": {"title": "loader", "body": "<main>\n<dd><p>An object that loads a module. It must define a method named\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">load_module()</span></code>. A loader is typically returned by a\n<a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">finder</span></a>. See <span class=\"target\" id=\"index-25\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0302/\"><strong>PEP 302</strong></a> for details and\n<a class=\"reference internal\" href=\"library/importlib.html#importlib.abc.Loader\" title=\"importlib.abc.Loader\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.abc.Loader</span></code></a> for an <a class=\"reference internal\" href=\"#term-abstract-base-class\"><span class=\"xref std std-term\">abstract base class</span></a>.</p>\n</dd>\n</main>\n"}, "magic method": {"title": "magic method", "body": "<main>\n<dd><p id=\"index-26\">An informal synonym for <a class=\"reference internal\" href=\"#term-special-method\"><span class=\"xref std std-term\">special method</span></a>.</p>\n</dd>\n</main>\n"}, "mapping": {"title": "mapping", "body": "<main>\n<dd><p>A container object that supports arbitrary key lookups and implements the\nmethods specified in the <a class=\"reference internal\" href=\"library/collections.abc.html#collections.abc.Mapping\" title=\"collections.abc.Mapping\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.abc.Mapping</span></code></a> or\n<a class=\"reference internal\" href=\"library/collections.abc.html#collections.abc.MutableMapping\" title=\"collections.abc.MutableMapping\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.abc.MutableMapping</span></code></a>\n<a class=\"reference internal\" href=\"library/collections.abc.html#collections-abstract-base-classes\"><span class=\"std std-ref\">abstract base classes</span></a>.  Examples\ninclude <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a>, <a class=\"reference internal\" href=\"library/collections.html#collections.defaultdict\" title=\"collections.defaultdict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.defaultdict</span></code></a>,\n<a class=\"reference internal\" href=\"library/collections.html#collections.OrderedDict\" title=\"collections.OrderedDict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.OrderedDict</span></code></a> and <a class=\"reference internal\" href=\"library/collections.html#collections.Counter\" title=\"collections.Counter\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.Counter</span></code></a>.</p>\n</dd>\n</main>\n"}, "meta path finder": {"title": "meta path finder", "body": "<main>\n<dd><p>A <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">finder</span></a> returned by a search of <a class=\"reference internal\" href=\"library/sys.html#sys.meta_path\" title=\"sys.meta_path\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.meta_path</span></code></a>.  Meta path\nfinders are related to, but different from <a class=\"reference internal\" href=\"#term-path-entry-finder\"><span class=\"xref std std-term\">path entry finders</span></a>.</p>\n<p>See <a class=\"reference internal\" href=\"library/importlib.html#importlib.abc.MetaPathFinder\" title=\"importlib.abc.MetaPathFinder\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.abc.MetaPathFinder</span></code></a> for the methods that meta path\nfinders implement.</p>\n</dd>\n</main>\n"}, "metaclass": {"title": "metaclass", "body": "<main>\n<dd><p>The class of a class.  Class definitions create a class name, a class\ndictionary, and a list of base classes.  The metaclass is responsible for\ntaking those three arguments and creating the class.  Most object oriented\nprogramming languages provide a default implementation.  What makes Python\nspecial is that it is possible to create custom metaclasses.  Most users\nnever need this tool, but when the need arises, metaclasses can provide\npowerful, elegant solutions.  They have been used for logging attribute\naccess, adding thread-safety, tracking object creation, implementing\nsingletons, and many other tasks.</p>\n<p>More information can be found in <a class=\"reference internal\" href=\"reference/datamodel.html#metaclasses\"><span class=\"std std-ref\">Metaclasses</span></a>.</p>\n</dd>\n</main>\n"}, "method": {"title": "method", "body": "<main>\n<dd><p>A function which is defined inside a class body.  If called as an attribute\nof an instance of that class, the method will get the instance object as\nits first <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a> (which is usually called <code class=\"docutils literal notranslate\"><span class=\"pre\">self</span></code>).\nSee <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a> and <a class=\"reference internal\" href=\"#term-nested-scope\"><span class=\"xref std std-term\">nested scope</span></a>.</p>\n</dd>\n</main>\n"}, "method resolution order": {"title": "method resolution order", "body": "<main>\n<dd><p>Method Resolution Order is the order in which base classes are searched\nfor a member during lookup. See <a class=\"reference external\" href=\"https://www.python.org/download/releases/2.3/mro/\">The Python 2.3 Method Resolution Order</a> for details of the\nalgorithm used by the Python interpreter since the 2.3 release.</p>\n</dd>\n</main>\n"}, "module": {"title": "module", "body": "<main>\n<dd><p>An object that serves as an organizational unit of Python code.  Modules\nhave a namespace containing arbitrary Python objects.  Modules are loaded\ninto Python by the process of <a class=\"reference internal\" href=\"#term-importing\"><span class=\"xref std std-term\">importing</span></a>.</p>\n<p>See also <a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">package</span></a>.</p>\n</dd>\n</main>\n"}, "module spec": {"title": "module spec", "body": "<main>\n<dd><p>A namespace containing the import-related information used to load a\nmodule. An instance of <a class=\"reference internal\" href=\"library/importlib.html#importlib.machinery.ModuleSpec\" title=\"importlib.machinery.ModuleSpec\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.machinery.ModuleSpec</span></code></a>.</p>\n</dd>\n</main>\n"}, "mro": {"title": "MRO", "body": "<main>\n<dd><p>See <a class=\"reference internal\" href=\"#term-method-resolution-order\"><span class=\"xref std std-term\">method resolution order</span></a>.</p>\n</dd>\n</main>\n"}, "mutable": {"title": "mutable", "body": "<main>\n<dd><p>Mutable objects can change their value but keep their <a class=\"reference internal\" href=\"library/functions.html#id\" title=\"id\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">id()</span></code></a>.  See\nalso <a class=\"reference internal\" href=\"#term-immutable\"><span class=\"xref std std-term\">immutable</span></a>.</p>\n</dd>\n</main>\n"}, "named tuple": {"title": "named tuple", "body": "<main>\n<dd><p>The term \u201cnamed tuple\u201d applies to any type or class that inherits from\ntuple and whose indexable elements are also accessible using named\nattributes.  The type or class may have other features as well.</p>\n<p>Several built-in types are named tuples, including the values returned\nby <a class=\"reference internal\" href=\"library/time.html#time.localtime\" title=\"time.localtime\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">time.localtime()</span></code></a> and <a class=\"reference internal\" href=\"library/os.html#os.stat\" title=\"os.stat\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.stat()</span></code></a>.  Another example is\n<a class=\"reference internal\" href=\"library/sys.html#sys.float_info\" title=\"sys.float_info\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.float_info</span></code></a>:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">float_info</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>                   <span class=\"c1\"># indexed access</span>\n<span class=\"go\">1024</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">float_info</span><span class=\"o\">.</span><span class=\"n\">max_exp</span>              <span class=\"c1\"># named field access</span>\n<span class=\"go\">1024</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">float_info</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">)</span>   <span class=\"c1\"># kind of tuple</span>\n<span class=\"go\">True</span>\n</pre></div>\n</div>\n<p>Some named tuples are built-in types (such as the above examples).\nAlternatively, a named tuple can be created from a regular class\ndefinition that inherits from <a class=\"reference internal\" href=\"library/stdtypes.html#tuple\" title=\"tuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tuple</span></code></a> and that defines named\nfields.  Such a class can be written by hand or it can be created with\nthe factory function <a class=\"reference internal\" href=\"library/collections.html#collections.namedtuple\" title=\"collections.namedtuple\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">collections.namedtuple()</span></code></a>.  The latter\ntechnique also adds some extra methods that may not be found in\nhand-written or built-in named tuples.</p>\n</dd>\n</main>\n"}, "namespace": {"title": "namespace", "body": "<main>\n<dd><p>The place where a variable is stored.  Namespaces are implemented as\ndictionaries.  There are the local, global and built-in namespaces as well\nas nested namespaces in objects (in methods).  Namespaces support\nmodularity by preventing naming conflicts.  For instance, the functions\n<a class=\"reference internal\" href=\"library/functions.html#open\" title=\"open\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">builtins.open</span></code></a> and <a class=\"reference internal\" href=\"library/os.html#os.open\" title=\"os.open\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.open()</span></code></a> are distinguished by\ntheir namespaces.  Namespaces also aid readability and maintainability by\nmaking it clear which module implements a function.  For instance, writing\n<a class=\"reference internal\" href=\"library/random.html#random.seed\" title=\"random.seed\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">random.seed()</span></code></a> or <a class=\"reference internal\" href=\"library/itertools.html#itertools.islice\" title=\"itertools.islice\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">itertools.islice()</span></code></a> makes it clear that those\nfunctions are implemented by the <a class=\"reference internal\" href=\"library/random.html#module-random\" title=\"random: Generate pseudo-random numbers with various common distributions.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">random</span></code></a> and <a class=\"reference internal\" href=\"library/itertools.html#module-itertools\" title=\"itertools: Functions creating iterators for efficient looping.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">itertools</span></code></a>\nmodules, respectively.</p>\n</dd>\n</main>\n"}, "namespace package": {"title": "namespace package", "body": "<main>\n<dd><p>A <span class=\"target\" id=\"index-27\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0420/\"><strong>PEP 420</strong></a> <a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">package</span></a> which serves only as a container for\nsubpackages.  Namespace packages may have no physical representation,\nand specifically are not like a <a class=\"reference internal\" href=\"#term-regular-package\"><span class=\"xref std std-term\">regular package</span></a> because they\nhave no <code class=\"docutils literal notranslate\"><span class=\"pre\">__init__.py</span></code> file.</p>\n<p>See also <a class=\"reference internal\" href=\"#term-module\"><span class=\"xref std std-term\">module</span></a>.</p>\n</dd>\n</main>\n"}, "nested scope": {"title": "nested scope", "body": "<main>\n<dd><p>The ability to refer to a variable in an enclosing definition.  For\ninstance, a function defined inside another function can refer to\nvariables in the outer function.  Note that nested scopes by default work\nonly for reference and not for assignment.  Local variables both read and\nwrite in the innermost scope.  Likewise, global variables read and write\nto the global namespace.  The <a class=\"reference internal\" href=\"reference/simple_stmts.html#nonlocal\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">nonlocal</span></code></a> allows writing to outer\nscopes.</p>\n</dd>\n</main>\n"}, "new-style class": {"title": "new-style class", "body": "<main>\n<dd><p>Old name for the flavor of classes now used for all class objects.  In\nearlier Python versions, only new-style classes could use Python\u2019s newer,\nversatile features like <a class=\"reference internal\" href=\"reference/datamodel.html#object.__slots__\" title=\"object.__slots__\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__slots__</span></code></a>, descriptors,\nproperties, <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getattribute__()</span></code>, class methods, and static methods.</p>\n</dd>\n</main>\n"}, "object": {"title": "object", "body": "<main>\n<dd><p>Any data with state (attributes or value) and defined behavior\n(methods).  Also the ultimate base class of any <a class=\"reference internal\" href=\"#term-new-style-class\"><span class=\"xref std std-term\">new-style\nclass</span></a>.</p>\n</dd>\n</main>\n"}, "package": {"title": "package", "body": "<main>\n<dd><p>A Python <a class=\"reference internal\" href=\"#term-module\"><span class=\"xref std std-term\">module</span></a> which can contain submodules or recursively,\nsubpackages.  Technically, a package is a Python module with a\n<code class=\"docutils literal notranslate\"><span class=\"pre\">__path__</span></code> attribute.</p>\n<p>See also <a class=\"reference internal\" href=\"#term-regular-package\"><span class=\"xref std std-term\">regular package</span></a> and <a class=\"reference internal\" href=\"#term-namespace-package\"><span class=\"xref std std-term\">namespace package</span></a>.</p>\n</dd>\n</main>\n"}, "parameter": {"title": "parameter", "body": "<main>\n<dd><p>A named entity in a <a class=\"reference internal\" href=\"#term-function\"><span class=\"xref std std-term\">function</span></a> (or method) definition that\nspecifies an <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a> (or in some cases, arguments) that the\nfunction can accept.  There are five kinds of parameter:</p>\n<ul>\n<li><p><em class=\"dfn\">positional-or-keyword</em>: specifies an argument that can be passed\neither <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">positionally</span></a> or as a <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">keyword argument</span></a>.  This is the default kind of parameter, for example <em>foo</em>\nand <em>bar</em> in the following:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">,</span> <span class=\"n\">bar</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n</ul>\n<ul id=\"positional-only-parameter\">\n<li><p><em class=\"dfn\">positional-only</em>: specifies an argument that can be supplied only\nby position. Positional-only parameters can be defined by including a\n<code class=\"docutils literal notranslate\"><span class=\"pre\">/</span></code> character in the parameter list of the function definition after\nthem, for example <em>posonly1</em> and <em>posonly2</em> in the following:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">posonly1</span><span class=\"p\">,</span> <span class=\"n\">posonly2</span><span class=\"p\">,</span> <span class=\"o\">/</span><span class=\"p\">,</span> <span class=\"n\">positional_or_keyword</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n</ul>\n<ul id=\"keyword-only-parameter\">\n<li><p><em class=\"dfn\">keyword-only</em>: specifies an argument that can be supplied only\nby keyword.  Keyword-only parameters can be defined by including a\nsingle var-positional parameter or bare <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code> in the parameter list\nof the function definition before them, for example <em>kw_only1</em> and\n<em>kw_only2</em> in the following:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"n\">kw_only1</span><span class=\"p\">,</span> <span class=\"n\">kw_only2</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n<li><p><em class=\"dfn\">var-positional</em>: specifies that an arbitrary sequence of\npositional arguments can be provided (in addition to any positional\narguments already accepted by other parameters).  Such a parameter can\nbe defined by prepending the parameter name with <code class=\"docutils literal notranslate\"><span class=\"pre\">*</span></code>, for example\n<em>args</em> in the following:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre></div>\n</div>\n</li>\n<li><p><em class=\"dfn\">var-keyword</em>: specifies that arbitrarily many keyword arguments\ncan be provided (in addition to any keyword arguments already accepted\nby other parameters).  Such a parameter can be defined by prepending\nthe parameter name with <code class=\"docutils literal notranslate\"><span class=\"pre\">**</span></code>, for example <em>kwargs</em> in the example\nabove.</p></li>\n</ul>\n<p>Parameters can specify both optional and required arguments, as well as\ndefault values for some optional arguments.</p>\n<p>See also the <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a> glossary entry, the FAQ question on\n<a class=\"reference internal\" href=\"faq/programming.html#faq-argument-vs-parameter\"><span class=\"std std-ref\">the difference between arguments and parameters</span></a>, the <a class=\"reference internal\" href=\"library/inspect.html#inspect.Parameter\" title=\"inspect.Parameter\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">inspect.Parameter</span></code></a> class, the\n<a class=\"reference internal\" href=\"reference/compound_stmts.html#function\"><span class=\"std std-ref\">Function definitions</span></a> section, and <span class=\"target\" id=\"index-28\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0362/\"><strong>PEP 362</strong></a>.</p>\n</dd>\n</main>\n"}, "path entry": {"title": "path entry", "body": "<main>\n<dd><p>A single location on the <a class=\"reference internal\" href=\"#term-import-path\"><span class=\"xref std std-term\">import path</span></a> which the <a class=\"reference internal\" href=\"#term-path-based-finder\"><span class=\"xref std std-term\">path\nbased finder</span></a> consults to find modules for importing.</p>\n</dd>\n</main>\n"}, "path entry finder": {"title": "path entry finder", "body": "<main>\n<dd><p>A <a class=\"reference internal\" href=\"#term-finder\"><span class=\"xref std std-term\">finder</span></a> returned by a callable on <a class=\"reference internal\" href=\"library/sys.html#sys.path_hooks\" title=\"sys.path_hooks\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path_hooks</span></code></a>\n(i.e. a <a class=\"reference internal\" href=\"#term-path-entry-hook\"><span class=\"xref std std-term\">path entry hook</span></a>) which knows how to locate modules given\na <a class=\"reference internal\" href=\"#term-path-entry\"><span class=\"xref std std-term\">path entry</span></a>.</p>\n<p>See <a class=\"reference internal\" href=\"library/importlib.html#importlib.abc.PathEntryFinder\" title=\"importlib.abc.PathEntryFinder\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">importlib.abc.PathEntryFinder</span></code></a> for the methods that path entry\nfinders implement.</p>\n</dd>\n</main>\n"}, "path entry hook": {"title": "path entry hook", "body": "<main>\n<dd><p>A callable on the <code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.path_hook</span></code> list which returns a <a class=\"reference internal\" href=\"#term-path-entry-finder\"><span class=\"xref std std-term\">path\nentry finder</span></a> if it knows how to find modules on a specific <a class=\"reference internal\" href=\"#term-path-entry\"><span class=\"xref std std-term\">path\nentry</span></a>.</p>\n</dd>\n</main>\n"}, "path based finder": {"title": "path based finder", "body": "<main>\n<dd><p>One of the default <a class=\"reference internal\" href=\"#term-meta-path-finder\"><span class=\"xref std std-term\">meta path finders</span></a> which\nsearches an <a class=\"reference internal\" href=\"#term-import-path\"><span class=\"xref std std-term\">import path</span></a> for modules.</p>\n</dd>\n</main>\n"}, "path-like object": {"title": "path-like object", "body": "<main>\n<dd><p>An object representing a file system path. A path-like object is either\na <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> or <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> object representing a path, or an object\nimplementing the <a class=\"reference internal\" href=\"library/os.html#os.PathLike\" title=\"os.PathLike\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">os.PathLike</span></code></a> protocol. An object that supports\nthe <a class=\"reference internal\" href=\"library/os.html#os.PathLike\" title=\"os.PathLike\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">os.PathLike</span></code></a> protocol can be converted to a <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> or\n<a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> file system path by calling the <a class=\"reference internal\" href=\"library/os.html#os.fspath\" title=\"os.fspath\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.fspath()</span></code></a> function;\n<a class=\"reference internal\" href=\"library/os.html#os.fsdecode\" title=\"os.fsdecode\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.fsdecode()</span></code></a> and <a class=\"reference internal\" href=\"library/os.html#os.fsencode\" title=\"os.fsencode\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">os.fsencode()</span></code></a> can be used to guarantee a\n<a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> or <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a> result instead, respectively. Introduced\nby <span class=\"target\" id=\"index-29\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0519/\"><strong>PEP 519</strong></a>.</p>\n</dd>\n</main>\n"}, "pep": {"title": "PEP", "body": "<main>\n<dd><p>Python Enhancement Proposal. A PEP is a design document\nproviding information to the Python community, or describing a new\nfeature for Python or its processes or environment. PEPs should\nprovide a concise technical specification and a rationale for proposed\nfeatures.</p>\n<p>PEPs are intended to be the primary mechanisms for proposing major new\nfeatures, for collecting community input on an issue, and for documenting\nthe design decisions that have gone into Python. The PEP author is\nresponsible for building consensus within the community and documenting\ndissenting opinions.</p>\n<p>See <span class=\"target\" id=\"index-30\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0001/\"><strong>PEP 1</strong></a>.</p>\n</dd>\n</main>\n"}, "portion": {"title": "portion", "body": "<main>\n<dd><p>A set of files in a single directory (possibly stored in a zip file)\nthat contribute to a namespace package, as defined in <span class=\"target\" id=\"index-31\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0420/\"><strong>PEP 420</strong></a>.</p>\n</dd>\n</main>\n"}, "positional argument": {"title": "positional argument", "body": "<main>\n<dd><p>See <a class=\"reference internal\" href=\"#term-argument\"><span class=\"xref std std-term\">argument</span></a>.</p>\n</dd>\n</main>\n"}, "provisional api": {"title": "provisional API", "body": "<main>\n<dd><p>A provisional API is one which has been deliberately excluded from\nthe standard library\u2019s backwards compatibility guarantees.  While major\nchanges to such interfaces are not expected, as long as they are marked\nprovisional, backwards incompatible changes (up to and including removal\nof the interface) may occur if deemed necessary by core developers.  Such\nchanges will not be made gratuitously \u2013 they will occur only if serious\nfundamental flaws are uncovered that were missed prior to the inclusion\nof the API.</p>\n<p>Even for provisional APIs, backwards incompatible changes are seen as\na \u201csolution of last resort\u201d - every attempt will still be made to find\na backwards compatible resolution to any identified problems.</p>\n<p>This process allows the standard library to continue to evolve over\ntime, without locking in problematic design errors for extended periods\nof time.  See <span class=\"target\" id=\"index-32\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0411/\"><strong>PEP 411</strong></a> for more details.</p>\n</dd>\n</main>\n"}, "provisional package": {"title": "provisional package", "body": "<main>\n<dd><p>See <a class=\"reference internal\" href=\"#term-provisional-API\"><span class=\"xref std std-term\">provisional API</span></a>.</p>\n</dd>\n</main>\n"}, "python 3000": {"title": "Python 3000", "body": "<main>\n<dd><p>Nickname for the Python 3.x release line (coined long ago when the\nrelease of version 3 was something in the distant future.)  This is also\nabbreviated \u201cPy3k\u201d.</p>\n</dd>\n</main>\n"}, "pythonic": {"title": "Pythonic", "body": "<main>\n<dd><p>An idea or piece of code which closely follows the most common idioms\nof the Python language, rather than implementing code using concepts\ncommon to other languages.  For example, a common idiom in Python is\nto loop over all elements of an iterable using a <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a>\nstatement.  Many other languages don\u2019t have this type of construct, so\npeople unfamiliar with Python sometimes use a numerical counter instead:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">food</span><span class=\"p\">)):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">food</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n</pre></div>\n</div>\n<p>As opposed to the cleaner, Pythonic method:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">for</span> <span class=\"n\">piece</span> <span class=\"ow\">in</span> <span class=\"n\">food</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">piece</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "qualified name": {"title": "qualified name", "body": "<main>\n<dd><p>A dotted name showing the \u201cpath\u201d from a module\u2019s global scope to a\nclass, function or method defined in that module, as defined in\n<span class=\"target\" id=\"index-33\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-3155/\"><strong>PEP 3155</strong></a>.  For top-level functions and classes, the qualified name\nis the same as the object\u2019s name:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">class</span> <span class=\"nc\">C</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span>    <span class=\"k\">class</span> <span class=\"nc\">D</span><span class=\"p\">:</span>\n<span class=\"gp\">... </span>        <span class=\"k\">def</span> <span class=\"nf\">meth</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>            <span class=\"k\">pass</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n<span class=\"go\">&#39;C&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">D</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n<span class=\"go\">&#39;C.D&#39;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">C</span><span class=\"o\">.</span><span class=\"n\">D</span><span class=\"o\">.</span><span class=\"n\">meth</span><span class=\"o\">.</span><span class=\"vm\">__qualname__</span>\n<span class=\"go\">&#39;C.D.meth&#39;</span>\n</pre></div>\n</div>\n<p>When used to refer to modules, the <em>fully qualified name</em> means the\nentire dotted path to the module, including any parent packages,\ne.g. <code class=\"docutils literal notranslate\"><span class=\"pre\">email.mime.text</span></code>:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">email.mime.text</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">email</span><span class=\"o\">.</span><span class=\"n\">mime</span><span class=\"o\">.</span><span class=\"n\">text</span><span class=\"o\">.</span><span class=\"vm\">__name__</span>\n<span class=\"go\">&#39;email.mime.text&#39;</span>\n</pre></div>\n</div>\n</dd>\n</main>\n"}, "reference count": {"title": "reference count", "body": "<main>\n<dd><p>The number of references to an object.  When the reference count of an\nobject drops to zero, it is deallocated.  Reference counting is\ngenerally not visible to Python code, but it is a key element of the\n<a class=\"reference internal\" href=\"#term-CPython\"><span class=\"xref std std-term\">CPython</span></a> implementation.  Programmers can call the\n<a class=\"reference internal\" href=\"library/sys.html#sys.getrefcount\" title=\"sys.getrefcount\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">sys.getrefcount()</span></code></a> function to return the\nreference count for a particular object.</p>\n</dd>\n</main>\n"}, "regular package": {"title": "regular package", "body": "<main>\n<dd><p>A traditional <a class=\"reference internal\" href=\"#term-package\"><span class=\"xref std std-term\">package</span></a>, such as a directory containing an\n<code class=\"docutils literal notranslate\"><span class=\"pre\">__init__.py</span></code> file.</p>\n<p>See also <a class=\"reference internal\" href=\"#term-namespace-package\"><span class=\"xref std std-term\">namespace package</span></a>.</p>\n</dd>\n</main>\n"}, "__slots__": {"title": "__slots__", "body": "<main>\n<dd><p>A declaration inside a class that saves memory by pre-declaring space for\ninstance attributes and eliminating instance dictionaries.  Though\npopular, the technique is somewhat tricky to get right and is best\nreserved for rare cases where there are large numbers of instances in a\nmemory-critical application.</p>\n</dd>\n</main>\n"}, "sequence": {"title": "sequence", "body": "<main>\n<dd><p>An <a class=\"reference internal\" href=\"#term-iterable\"><span class=\"xref std std-term\">iterable</span></a> which supports efficient element access using integer\nindices via the <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code> special method and defines a\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__len__()</span></code> method that returns the length of the sequence.\nSome built-in sequence types are <a class=\"reference internal\" href=\"library/stdtypes.html#list\" title=\"list\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">list</span></code></a>, <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a>,\n<a class=\"reference internal\" href=\"library/stdtypes.html#tuple\" title=\"tuple\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">tuple</span></code></a>, and <a class=\"reference internal\" href=\"library/stdtypes.html#bytes\" title=\"bytes\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">bytes</span></code></a>. Note that <a class=\"reference internal\" href=\"library/stdtypes.html#dict\" title=\"dict\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">dict</span></code></a> also\nsupports <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code> and <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__len__()</span></code>, but is considered a\nmapping rather than a sequence because the lookups use arbitrary\n<a class=\"reference internal\" href=\"#term-immutable\"><span class=\"xref std std-term\">immutable</span></a> keys rather than integers.</p>\n<p>The <a class=\"reference internal\" href=\"library/collections.abc.html#collections.abc.Sequence\" title=\"collections.abc.Sequence\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">collections.abc.Sequence</span></code></a> abstract base class\ndefines a much richer interface that goes beyond just\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__getitem__()</span></code> and <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__len__()</span></code>, adding <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">count()</span></code>,\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">index()</span></code>, <code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__contains__()</span></code>, and\n<code class=\"xref py py-meth docutils literal notranslate\"><span class=\"pre\">__reversed__()</span></code>. Types that implement this expanded\ninterface can be registered explicitly using\n<a class=\"reference internal\" href=\"library/abc.html#abc.ABCMeta.register\" title=\"abc.ABCMeta.register\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">register()</span></code></a>.</p>\n</dd>\n</main>\n"}, "set comprehension": {"title": "set comprehension", "body": "<main>\n<dd><p>A compact way to process all or part of the elements in an iterable and\nreturn a set with the results. <code class=\"docutils literal notranslate\"><span class=\"pre\">results</span> <span class=\"pre\">=</span> <span class=\"pre\">{c</span> <span class=\"pre\">for</span> <span class=\"pre\">c</span> <span class=\"pre\">in</span> <span class=\"pre\">'abracadabra'</span> <span class=\"pre\">if</span>\n<span class=\"pre\">c</span> <span class=\"pre\">not</span> <span class=\"pre\">in</span> <span class=\"pre\">'abc'}</span></code> generates the set of strings <code class=\"docutils literal notranslate\"><span class=\"pre\">{'r',</span> <span class=\"pre\">'d'}</span></code>.  See\n<a class=\"reference internal\" href=\"reference/expressions.html#comprehensions\"><span class=\"std std-ref\">Displays for lists, sets and dictionaries</span></a>.</p>\n</dd>\n</main>\n"}, "single dispatch": {"title": "single dispatch", "body": "<main>\n<dd><p>A form of <a class=\"reference internal\" href=\"#term-generic-function\"><span class=\"xref std std-term\">generic function</span></a> dispatch where the implementation is\nchosen based on the type of a single argument.</p>\n</dd>\n</main>\n"}, "slice": {"title": "slice", "body": "<main>\n<dd><p>An object usually containing a portion of a <a class=\"reference internal\" href=\"#term-sequence\"><span class=\"xref std std-term\">sequence</span></a>.  A slice is\ncreated using the subscript notation, <code class=\"docutils literal notranslate\"><span class=\"pre\">[]</span></code> with colons between numbers\nwhen several are given, such as in <code class=\"docutils literal notranslate\"><span class=\"pre\">variable_name[1:3:5]</span></code>.  The bracket\n(subscript) notation uses <a class=\"reference internal\" href=\"library/functions.html#slice\" title=\"slice\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">slice</span></code></a> objects internally.</p>\n</dd>\n</main>\n"}, "special method": {"title": "special method", "body": "<main>\n<dd><p id=\"index-34\">A method that is called implicitly by Python to execute a certain\noperation on a type, such as addition.  Such methods have names starting\nand ending with double underscores.  Special methods are documented in\n<a class=\"reference internal\" href=\"reference/datamodel.html#specialnames\"><span class=\"std std-ref\">Special method names</span></a>.</p>\n</dd>\n</main>\n"}, "statement": {"title": "statement", "body": "<main>\n<dd><p>A statement is part of a suite (a \u201cblock\u201d of code).  A statement is either\nan <a class=\"reference internal\" href=\"#term-expression\"><span class=\"xref std std-term\">expression</span></a> or one of several constructs with a keyword, such\nas <a class=\"reference internal\" href=\"reference/compound_stmts.html#if\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">if</span></code></a>, <a class=\"reference internal\" href=\"reference/compound_stmts.html#while\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">while</span></code></a> or <a class=\"reference internal\" href=\"reference/compound_stmts.html#for\"><code class=\"xref std std-keyword docutils literal notranslate\"><span class=\"pre\">for</span></code></a>.</p>\n</dd>\n</main>\n"}, "strong reference": {"title": "strong reference", "body": "<main>\n<dd><p>In Python\u2019s C API, a strong reference is a reference to an object\nwhich is owned by the code holding the reference.  The strong\nreference is taken by calling <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_INCREF\" title=\"Py_INCREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_INCREF()</span></code></a> when the\nreference is created and released with <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_DECREF\" title=\"Py_DECREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_DECREF()</span></code></a>\nwhen the reference is deleted.</p>\n<p>The <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_NewRef\" title=\"Py_NewRef\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_NewRef()</span></code></a> function can be used to create a strong reference\nto an object. Usually, the <a class=\"reference internal\" href=\"c-api/refcounting.html#c.Py_DECREF\" title=\"Py_DECREF\"><code class=\"xref c c-func docutils literal notranslate\"><span class=\"pre\">Py_DECREF()</span></code></a> function must be called on\nthe strong reference before exiting the scope of the strong reference, to\navoid leaking one reference.</p>\n<p>See also <a class=\"reference internal\" href=\"#term-borrowed-reference\"><span class=\"xref std std-term\">borrowed reference</span></a>.</p>\n</dd>\n</main>\n"}, "text encoding": {"title": "text encoding", "body": "<main>\n<dd><p>A string in Python is a sequence of Unicode code points (in range\n<code class=\"docutils literal notranslate\"><span class=\"pre\">U+0000</span></code>\u2013<code class=\"docutils literal notranslate\"><span class=\"pre\">U+10FFFF</span></code>). To store or transfer a string, it needs to be\nserialized as a sequence of bytes.</p>\n<p>Serializing a string into a sequence of bytes is known as \u201cencoding\u201d, and\nrecreating the string from the sequence of bytes is known as \u201cdecoding\u201d.</p>\n<p>There are a variety of different text serialization\n<a class=\"reference internal\" href=\"library/codecs.html#standard-encodings\"><span class=\"std std-ref\">codecs</span></a>, which are collectively referred to as\n\u201ctext encodings\u201d.</p>\n</dd>\n</main>\n"}, "text file": {"title": "text file", "body": "<main>\n<dd><p>A <a class=\"reference internal\" href=\"#term-file-object\"><span class=\"xref std std-term\">file object</span></a> able to read and write <a class=\"reference internal\" href=\"library/stdtypes.html#str\" title=\"str\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">str</span></code></a> objects.\nOften, a text file actually accesses a byte-oriented datastream\nand handles the <a class=\"reference internal\" href=\"#term-text-encoding\"><span class=\"xref std std-term\">text encoding</span></a> automatically.\nExamples of text files are files opened in text mode (<code class=\"docutils literal notranslate\"><span class=\"pre\">'r'</span></code> or <code class=\"docutils literal notranslate\"><span class=\"pre\">'w'</span></code>),\n<a class=\"reference internal\" href=\"library/sys.html#sys.stdin\" title=\"sys.stdin\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdin</span></code></a>, <a class=\"reference internal\" href=\"library/sys.html#sys.stdout\" title=\"sys.stdout\"><code class=\"xref py py-data docutils literal notranslate\"><span class=\"pre\">sys.stdout</span></code></a>, and instances of\n<a class=\"reference internal\" href=\"library/io.html#io.StringIO\" title=\"io.StringIO\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">io.StringIO</span></code></a>.</p>\n<p>See also <a class=\"reference internal\" href=\"#term-binary-file\"><span class=\"xref std std-term\">binary file</span></a> for a file object able to read and write\n<a class=\"reference internal\" href=\"#term-bytes-like-object\"><span class=\"xref std std-term\">bytes-like objects</span></a>.</p>\n</dd>\n</main>\n"}, "triple-quoted string": {"title": "triple-quoted string", "body": "<main>\n<dd><p>A string which is bound by three instances of either a quotation mark\n(\u201d) or an apostrophe (\u2018).  While they don\u2019t provide any functionality\nnot available with single-quoted strings, they are useful for a number\nof reasons.  They allow you to include unescaped single and double\nquotes within a string and they can span multiple lines without the\nuse of the continuation character, making them especially useful when\nwriting docstrings.</p>\n</dd>\n</main>\n"}, "type": {"title": "type", "body": "<main>\n<dd><p>The type of a Python object determines what kind of object it is; every\nobject has a type.  An object\u2019s type is accessible as its\n<a class=\"reference internal\" href=\"library/stdtypes.html#instance.__class__\" title=\"instance.__class__\"><code class=\"xref py py-attr docutils literal notranslate\"><span class=\"pre\">__class__</span></code></a> attribute or can be retrieved with\n<code class=\"docutils literal notranslate\"><span class=\"pre\">type(obj)</span></code>.</p>\n</dd>\n</main>\n"}, "type alias": {"title": "type alias", "body": "<main>\n<dd><p>A synonym for a type, created by assigning the type to an identifier.</p>\n<p>Type aliases are useful for simplifying <a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hints</span></a>.\nFor example:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">remove_gray_shades</span><span class=\"p\">(</span>\n        <span class=\"n\">colors</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]:</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>could be made more readable like this:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">Color</span> <span class=\"o\">=</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">remove_gray_shades</span><span class=\"p\">(</span><span class=\"n\">colors</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Color</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Color</span><span class=\"p\">]:</span>\n    <span class=\"k\">pass</span>\n</pre></div>\n</div>\n<p>See <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a> and <span class=\"target\" id=\"index-35\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, which describe this functionality.</p>\n</dd>\n</main>\n"}, "type hint": {"title": "type hint", "body": "<main>\n<dd><p>An <a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotation</span></a> that specifies the expected type for a variable, a class\nattribute, or a function parameter or return value.</p>\n<p>Type hints are optional and are not enforced by Python but\nthey are useful to static type analysis tools, and aid IDEs with code\ncompletion and refactoring.</p>\n<p>Type hints of global variables, class attributes, and functions,\nbut not local variables, can be accessed using\n<a class=\"reference internal\" href=\"library/typing.html#typing.get_type_hints\" title=\"typing.get_type_hints\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">typing.get_type_hints()</span></code></a>.</p>\n<p>See <a class=\"reference internal\" href=\"library/typing.html#module-typing\" title=\"typing: Support for type hints (see :pep:`484`).\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">typing</span></code></a> and <span class=\"target\" id=\"index-36\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>, which describe this functionality.</p>\n</dd>\n</main>\n"}, "universal newlines": {"title": "universal newlines", "body": "<main>\n<dd><p>A manner of interpreting text streams in which all of the following are\nrecognized as ending a line: the Unix end-of-line convention <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\n'</span></code>,\nthe Windows convention <code class=\"docutils literal notranslate\"><span class=\"pre\">'\\r\\n'</span></code>, and the old Macintosh convention\n<code class=\"docutils literal notranslate\"><span class=\"pre\">'\\r'</span></code>.  See <span class=\"target\" id=\"index-37\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0278/\"><strong>PEP 278</strong></a> and <span class=\"target\" id=\"index-38\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-3116/\"><strong>PEP 3116</strong></a>, as well as\n<a class=\"reference internal\" href=\"library/stdtypes.html#bytes.splitlines\" title=\"bytes.splitlines\"><code class=\"xref py py-func docutils literal notranslate\"><span class=\"pre\">bytes.splitlines()</span></code></a> for an additional use.</p>\n</dd>\n</main>\n"}, "variable annotation": {"title": "variable annotation", "body": "<main>\n<dd><p>An <a class=\"reference internal\" href=\"#term-annotation\"><span class=\"xref std std-term\">annotation</span></a> of a variable or a class attribute.</p>\n<p>When annotating a variable or a class attribute, assignment is optional:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">C</span><span class=\"p\">:</span>\n    <span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"s1\">&#39;annotation&#39;</span>\n</pre></div>\n</div>\n<p>Variable annotations are usually used for\n<a class=\"reference internal\" href=\"#term-type-hint\"><span class=\"xref std std-term\">type hints</span></a>: for example this variable is expected to take\n<a class=\"reference internal\" href=\"library/functions.html#int\" title=\"int\"><code class=\"xref py py-class docutils literal notranslate\"><span class=\"pre\">int</span></code></a> values:</p>\n<div class=\"highlight-python3 notranslate\"><div class=\"highlight\"><pre><span></span><span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n</pre></div>\n</div>\n<p>Variable annotation syntax is explained in section <a class=\"reference internal\" href=\"reference/simple_stmts.html#annassign\"><span class=\"std std-ref\">Annotated assignment statements</span></a>.</p>\n<p>See <a class=\"reference internal\" href=\"#term-function-annotation\"><span class=\"xref std std-term\">function annotation</span></a>, <span class=\"target\" id=\"index-39\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0484/\"><strong>PEP 484</strong></a>\nand <span class=\"target\" id=\"index-40\"></span><a class=\"pep reference external\" href=\"https://peps.python.org/pep-0526/\"><strong>PEP 526</strong></a>, which describe this functionality.\nAlso see <a class=\"reference internal\" href=\"howto/annotations.html#annotations-howto\"><span class=\"std std-ref\">Annotations Best Practices</span></a>\nfor best practices on working with annotations.</p>\n</dd>\n</main>\n"}, "virtual environment": {"title": "virtual environment", "body": "<main>\n<dd><p>A cooperatively isolated runtime environment that allows Python users\nand applications to install and upgrade Python distribution packages\nwithout interfering with the behaviour of other Python applications\nrunning on the same system.</p>\n<p>See also <a class=\"reference internal\" href=\"library/venv.html#module-venv\" title=\"venv: Creation of virtual environments.\"><code class=\"xref py py-mod docutils literal notranslate\"><span class=\"pre\">venv</span></code></a>.</p>\n</dd>\n</main>\n"}, "virtual machine": {"title": "virtual machine", "body": "<main>\n<dd><p>A computer defined entirely in software.  Python\u2019s virtual machine\nexecutes the <a class=\"reference internal\" href=\"#term-bytecode\"><span class=\"xref std std-term\">bytecode</span></a> emitted by the bytecode compiler.</p>\n</dd>\n</main>\n"}, "zen of python": {"title": "Zen of Python", "body": "<main>\n<dd><p>Listing of Python design principles and philosophies that are helpful in\nunderstanding and using the language.  The listing can be found by typing\n\u201c<code class=\"docutils literal notranslate\"><span class=\"pre\">import</span> <span class=\"pre\">this</span></code>\u201d at the interactive prompt.</p>\n</dd>\n</main>\n"}, "start line": {"title": "start line", "body": "<main>\n<dd><p>The line <code class=\"docutils literal notranslate\"><span class=\"pre\">/*[clinic</span> <span class=\"pre\">input]</span></code>.\nThis line marks the beginning of Argument Clinic input.\nNote that the <em>start line</em> opens a C block comment.</p>\n</dd>\n</main>\n"}, "end line": {"title": "end line", "body": "<main>\n<dd><p>The line <code class=\"docutils literal notranslate\"><span class=\"pre\">[clinic</span> <span class=\"pre\">start</span> <span class=\"pre\">generated</span> <span class=\"pre\">code]*/</span></code>.\nThe <em>end line</em> marks the _end_ of Argument Clinic <a class=\"reference internal\" href=\"#term-input\"><span class=\"xref std std-term\">input</span></a>,\nbut at the same time marks the _start_ of Argument Clinic <a class=\"reference internal\" href=\"#term-output\"><span class=\"xref std std-term\">output</span></a>,\nthus the text <em>\u201cclinic start start generated code\u201d</em>\nNote that the <em>end line</em> closes the C block comment opened\nby the <em>start line</em>.</p>\n</dd>\n</main>\n"}, "checksum": {"title": "checksum", "body": "<main>\n<dd><p>A hash to distinguish unique <a class=\"reference internal\" href=\"#term-input\"><span class=\"xref std std-term\">inputs</span></a>\nand <a class=\"reference internal\" href=\"#term-output\"><span class=\"xref std std-term\">outputs</span></a>.</p>\n</dd>\n</main>\n"}, "checksum line": {"title": "checksum line", "body": "<main>\n<dd><p>A line that looks like <code class=\"docutils literal notranslate\"><span class=\"pre\">/*[clinic</span> <span class=\"pre\">end</span> <span class=\"pre\">generated</span> <span class=\"pre\">code:</span> <span class=\"pre\">...]*/</span></code>.\nThe three dots will be replaced by a <a class=\"reference internal\" href=\"#term-checksum\"><span class=\"xref std std-term\">checksum</span></a> generated from the\n<a class=\"reference internal\" href=\"#term-input\"><span class=\"xref std std-term\">input</span></a>, and a <a class=\"reference internal\" href=\"#term-checksum\"><span class=\"xref std std-term\">checksum</span></a> generated from the <a class=\"reference internal\" href=\"#term-output\"><span class=\"xref std std-term\">output</span></a>.\nThe checksum line marks the end of Argument Clinic generated code,\nand is used by Argument Clinic to determine if it needs to regenerate\noutput.</p>\n</dd>\n</main>\n"}, "input": {"title": "input", "body": "<main>\n<dd><p>The text between the <a class=\"reference internal\" href=\"#term-start-line\"><span class=\"xref std std-term\">start line</span></a> and the <a class=\"reference internal\" href=\"#term-end-line\"><span class=\"xref std std-term\">end line</span></a>.\nNote that the start and end lines open and close a C block comment;\nthe <em>input</em> is thus a part of that same C block comment.</p>\n</dd>\n</main>\n"}, "output": {"title": "output", "body": "<main>\n<dd><p>The text between the <a class=\"reference internal\" href=\"#term-end-line\"><span class=\"xref std std-term\">end line</span></a> and the <a class=\"reference internal\" href=\"#term-checksum-line\"><span class=\"xref std std-term\">checksum line</span></a>.</p>\n</dd>\n</main>\n"}, "block": {"title": "block", "body": "<main>\n<dd><p>All text from the <a class=\"reference internal\" href=\"#term-start-line\"><span class=\"xref std std-term\">start line</span></a> to the <a class=\"reference internal\" href=\"#term-checksum-line\"><span class=\"xref std std-term\">checksum line</span></a> inclusively.</p>\n</dd>\n</main>\n"}}